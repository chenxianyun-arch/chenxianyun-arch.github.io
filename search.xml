<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES6对象新增语法</title>
      <link href="/2020/07/28/fontend/ES6%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/07/28/fontend/ES6%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-用来获取对象的数组的方式"><a href="#1-用来获取对象的数组的方式" class="headerlink" title="1 用来获取对象的数组的方式"></a>1 用来获取对象的数组的方式</h2><pre><code class="js">const obj = {    name: &quot;chenxianyun&quot;,    password: &quot;123456&quot;,    faviorties: [&#39;篮球&#39;,&#39;足球&#39;,&#39;乒乓球&#39;]  }  console.log(Object.keys(obj))  console.log(Object.values(obj))  console.log(Object.entries(obj))</code></pre><h2 id="2-实现对象的组合的打印方式"><a href="#2-实现对象的组合的打印方式" class="headerlink" title="2 实现对象的组合的打印方式"></a>2 实现对象的组合的打印方式</h2><pre><code class="js">const obj1 = {}  const obj2 = {number1:4}  const obj3 = {number2:3}  const obj = Object.assign(obj1,obj2,obj3)  console.log(obj)</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6对象新增方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6箭头函数</title>
      <link href="/2020/07/28/fontend/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2020/07/28/fontend/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-以前不用箭头函数的方式进行函数对象的编程"><a href="#1-以前不用箭头函数的方式进行函数对象的编程" class="headerlink" title="1 以前不用箭头函数的方式进行函数对象的编程"></a>1 以前不用箭头函数的方式进行函数对象的编程</h2><pre><code class="js">const obj = {  name: &quot;陈贤云&quot;,  password: &quot;d123455&quot;}function sayName(obj){  console.log(obj.name)}//进行调用,打印名字sayName(obj)</code></pre><h2 id="2-现在有箭头函数就可以这样进行编程"><a href="#2-现在有箭头函数就可以这样进行编程" class="headerlink" title="2 现在有箭头函数就可以这样进行编程"></a>2 现在有箭头函数就可以这样进行编程</h2><pre><code class="js">const obj = {name:&quot;chexianyun&quot;,password:&quot;hahah&quot;}  var sayHello = ({name}) =&gt; {console.log(name)}  sayHello(obj)//进行对象的解构和箭头函数的双利用var name = ({name}) =&gt; {console.log(name)}//这里需要总结一下的就是{name}是传递进来的对象里面的name属性，然后打印这个name属性</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 箭头函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中数据的加和减的区别</title>
      <link href="/2020/07/27/fontend/js%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%A0%E5%92%8C%E5%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/27/fontend/js%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%A0%E5%92%8C%E5%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="js中加减的区别和联系"><a href="#js中加减的区别和联系" class="headerlink" title="js中加减的区别和联系"></a>js中加减的区别和联系</h1><h2 id="1-js变量都是可以用var来进行修饰的"><a href="#1-js变量都是可以用var来进行修饰的" class="headerlink" title="1 js变量都是可以用var来进行修饰的"></a>1 js变量都是可以用var来进行修饰的</h2><pre><code class="js">var number1 = 1 //数字var str = &quot;&quot; //字符串var bool = false //正确或错误var obj = {}  //对象var arr = []  //数组</code></pre><h2 id="2-怎样进行字符串与数字进行相加的结果进行比较"><a href="#2-怎样进行字符串与数字进行相加的结果进行比较" class="headerlink" title="2.怎样进行字符串与数字进行相加的结果进行比较"></a>2.怎样进行字符串与数字进行相加的结果进行比较</h2><pre><code class="js">var x = 1 + &quot;3&quot; //输出结果为13，typeof(x) = String var y = 1 - &quot;4&quot; //。。。。为-3， 。。。。。 = Number</code></pre><ul><li>为什么会出现这种情况呢，因为相加的时候相当于进行<strong><em>拼接字符串</em></strong> 而在进行 - 的时候相当于进行数字的想加减</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> js加减的区别和联系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6函数优化</title>
      <link href="/2020/07/27/fontend/ES6%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96/"/>
      <url>/2020/07/27/fontend/ES6%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-什么是函数优化"><a href="#1-什么是函数优化" class="headerlink" title="1 什么是函数优化"></a>1 什么是函数优化</h2><ul><li>在以前编写js代码的时候，函数传参，传递参数的时候设置参数默认值的时候，是下面的这种写法<pre><code class="js">function sayHello(a,b){// 利用逻辑或来进行设置默认值b = b || 1return a+b}</code></pre></li><li>现在的编写js代码的传递参数，用ES6的语法<pre><code class="js">//意思就是如果没有传递进来的b，那么b就等于1function sayHello(a,b = 1){return a+b}</code></pre><h2 id="2-不定参数的用法"><a href="#2-不定参数的用法" class="headerlink" title="2 不定参数的用法"></a>2 不定参数的用法</h2><pre><code class="js">//目的是传递进来任意长度的参数function sayHello(...values){console.log(values)}</code></pre></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数优化 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6语法中的字符串模板</title>
      <link href="/2020/07/27/fontend/ES6%E8%AF%AD%E6%B3%95%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/07/27/fontend/ES6%E8%AF%AD%E6%B3%95%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="首先这个是我面试的时候回答错误了的（尴尬得一批）"><a href="#首先这个是我面试的时候回答错误了的（尴尬得一批）" class="headerlink" title="首先这个是我面试的时候回答错误了的（尴尬得一批）"></a>首先这个是我面试的时候回答错误了的（尴尬得一批）</h1><h2 id="1-什么是字符串模板"><a href="#1-什么是字符串模板" class="headerlink" title="1 什么是字符串模板"></a>1 什么是字符串模板</h2><ul><li>字符串模板就是可以用字符串模板不用再次进行拼接字符串的操作了<br>比如我们以前写js<pre><code class="js">//以前的写法let app = &quot;&lt;div&gt;是是是&lt;/div&gt;&quot;+&quot;&lt;div&gt;是是是&lt;/div&gt;&quot;//现在的写法let app = `&lt;div&gt;是是是&lt;/div&gt;&lt;div&gt;是是是&lt;/div&gt;`//这里的引号是反引号，我当时说成了模板字符串（主要是我不知道反引号，我说的是tab键上面的那个键，我靠）</code></pre></li></ul><h2 id="2-模板字符串的其他用法"><a href="#2-模板字符串的其他用法" class="headerlink" title="2 模板字符串的其他用法"></a>2 模板字符串的其他用法</h2><ul><li>可以在字符串里面写表达式<pre><code class="js">function sayHello(){return &quot;我是一个函数&quot;}</code></pre></li></ul><p>//比如下面我写的这个<br>let person = <code>我是${name},今年${age}岁了，我想说${sayHello()}</code></p><pre><code>---</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6语法-引用类型的解构与赋值</title>
      <link href="/2020/07/27/fontend/ES6%E8%AF%AD%E6%B3%95-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A7%A3%E6%9E%84%E4%B8%8E%E8%B5%8B%E5%80%BC/"/>
      <url>/2020/07/27/fontend/ES6%E8%AF%AD%E6%B3%95-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A7%A3%E6%9E%84%E4%B8%8E%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数组的解构方法"><a href="#1-数组的解构方法" class="headerlink" title="1 数组的解构方法"></a>1 数组的解构方法</h2><pre><code class="js">/*以前老的方式*/  var arr = [1,2,3]  //通过以前的方法的话我们是通过下标一个个取到具体的值来进行赋值，像下面这样  var index0 = arr[0]  var index1 = arr[1]  var index2 = arr[2]  console.log(index0,index1,index2)  /*现在新的方式*/  let arr1 = [2,3,5]  let [a,b,c] = arr1//核心代码就在这里，通过直接赋值的方式，就可以取到对应的数组item  console.log(a,b,c)</code></pre><h2 id="对象的解构方法"><a href="#对象的解构方法" class="headerlink" title="对象的解构方法"></a>对象的解构方法</h2><pre><code class="js">//以前的老方式进行对象的输出打印const person = {name:&#39;chenxianyun&#39;,age:18}  // 以前老的方式拿数据  const name = person.name  const password = person.password  console.log(name,password)//现在新的解构对象的方式const person = {name:&#39;chenxianyun&#39;,age:18}  // 以前老的方式拿数据  // const name = person.name  // const password = person.password  // console.log(name,password)  //现在新的解构对象的方式  const {name,age} = person  console.log(name,age)</code></pre><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 解构与赋值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中变量提升let关键字</title>
      <link href="/2020/07/27/fontend/js%E4%B8%AD%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87let%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/07/27/fontend/js%E4%B8%AD%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87let%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-js中变量提升什么意思"><a href="#1-js中变量提升什么意思" class="headerlink" title="1.js中变量提升什么意思"></a>1.js中变量提升什么意思</h1><ul><li>接下来我将用一个代码来进行解释<pre><code class="js">console.log(a)//这个是打印undifined，因为变量声明了，没有进行赋值，就会报这个错var a = 10   //这里的变量提升到上面去了，所以变量就往上进行提升console.log(b) //这里打印Uncaught ReferenceError: Cannot access &#39;b&#39; before initialization，意思就是变量没有进行初始化let b = 20   //因为let 声明的变量是不存在变量提升的</code></pre></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解js闭包</title>
      <link href="/2020/07/19/fontend/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E9%97%AD%E5%8C%85/"/>
      <url>/2020/07/19/fontend/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="深入理解js闭包"><a href="#深入理解js闭包" class="headerlink" title="深入理解js闭包"></a>深入理解js闭包</h1><h2 id="1-首先我们在解决这个问题之前我们先来理解下面这个内存模型"><a href="#1-首先我们在解决这个问题之前我们先来理解下面这个内存模型" class="headerlink" title="1.首先我们在解决这个问题之前我们先来理解下面这个内存模型"></a>1.首先我们在解决这个问题之前我们先来理解下面这个内存模型</h2><p><img src="https://upload-images.jianshu.io/upload_images/22769532-e84b140b86bae53d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>解释：基本数据类型存放的直接是值是栈中的数据段，而引用数据类型是存放的是内存地址，将变量赋值给另外一个变量实际上是将原引用的值保存给另外一个变量，另外一个变量就可以修改对象里面的具体内容</li></ul><h2 id="2-有关闭包的图-我也没有完全看懂，跟着抄了一遍"><a href="#2-有关闭包的图-我也没有完全看懂，跟着抄了一遍" class="headerlink" title="2.有关闭包的图(我也没有完全看懂，跟着抄了一遍)"></a>2.有关闭包的图(我也没有完全看懂，跟着抄了一遍)</h2><p><img src="https://upload-images.jianshu.io/upload_images/22769532-145f9625d444ba41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
            <tag> 函数作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中this的指向问题</title>
      <link href="/2020/07/19/fontend/js%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/19/fontend/js%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="js中this指向的问题"><a href="#js中this指向的问题" class="headerlink" title="js中this指向的问题"></a>js中this指向的问题</h1><ul><li>这样吧，我先说结论好了，不想看的小伙伴或者知道原理的可以直接记公式</li><li>函数直接被调用时this则指向window（也就是没有.的情况），函数作为某对象的方法调用时（也就是谁调用了这个函数，this就指向调用这个方法的对象），this指向该对象，而箭头函数没有执行上下文，取决于他就近的外面的一层非箭头函数的函数（箭头函数没有执行上下文，取决于最近的非箭头函数的那个函数）。</li></ul><h1 id="下面我就来进行一一验证"><a href="#下面我就来进行一一验证" class="headerlink" title="下面我就来进行一一验证"></a>下面我就来进行一一验证</h1><h2 id="1-寻找”-”，如果没有找到这个点，那么this就指向window"><a href="#1-寻找”-”，如果没有找到这个点，那么this就指向window" class="headerlink" title="1 寻找”.”，如果没有找到这个点，那么this就指向window"></a>1 寻找”.”，如果没有找到这个点，那么this就指向window</h2><pre><code class="js">var app = {  name: &quot;cxy&quot;}//这个是指向的window，可以自己将代码copy进浏览器里面运行试试console.log(this)</code></pre><ul><li>还有一个就是函数调用的例子<pre><code class="js">function foo(callback){  callback(); //调用其实在这里，你是找不到“.”的}foo(function(){  console.log(this);  //自己去运行代码看this指向谁})//匿名函数里面打印this，没有任何的. 所以指向window，不信可以自己运行一下试试</code></pre><h2 id="2-寻找”-”前面一层的那个对象，如果前面一层是对象或者函数，那this就指向这个函数或对象"><a href="#2-寻找”-”前面一层的那个对象，如果前面一层是对象或者函数，那this就指向这个函数或对象" class="headerlink" title="2 寻找”.”前面一层的那个对象，如果前面一层是对象或者函数，那this就指向这个函数或对象"></a>2 寻找”.”前面一层的那个对象，如果前面一层是对象或者函数，那this就指向这个函数或对象</h2><pre><code class="js">var person = {naem: &quot;cxy&quot;}</code></pre></li></ul><p>person.sayHello = function(){<br>  console.log(this)<br>}</p><p>// 执行<br>person.sayHello()<br>// this 指向的是调用该方法的对象</p><pre><code>## 3 调用语句中有多个.```jsvar person = {name:111}person.height = {heig: 1.8}person.height.hello = function(){  console.log(this)}person.height.hello()// 打印的this指向最近调用方法的对象</code></pre><h2 id="4-通过this引出一个问题就是原型和原型链"><a href="#4-通过this引出一个问题就是原型和原型链" class="headerlink" title="4 通过this引出一个问题就是原型和原型链"></a>4 通过this引出一个问题就是原型和原型链</h2><h3 id="4-1-什么是原型，有待我继续研究一下"><a href="#4-1-什么是原型，有待我继续研究一下" class="headerlink" title="4.1 什么是原型，有待我继续研究一下"></a>4.1 什么是原型，有待我继续研究一下</h3><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this指向 </tag>
            
            <tag> 记忆大法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中匿名函数的应用场景</title>
      <link href="/2020/07/17/fontend/js%E4%B8%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2020/07/17/fontend/js%E4%B8%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="js中匿名函数的使用场景"><a href="#js中匿名函数的使用场景" class="headerlink" title="js中匿名函数的使用场景"></a>js中匿名函数的使用场景</h1><h2 id="1-绑定事件"><a href="#1-绑定事件" class="headerlink" title="1.绑定事件"></a>1.绑定事件</h2><pre><code class="javascript">//1. 获取元素保存到变量里面 var btn = document.getElementById(&#39;mybtn&#39;)//2. 给变量添加点击事件，后面的function是没有名字的，就叫做匿名函数 btn.onclick = function () {    alert(&quot;点击了按钮&quot;); }</code></pre><h2 id="2-绑定对象上面"><a href="#2-绑定对象上面" class="headerlink" title="2.绑定对象上面"></a>2.绑定对象上面</h2><pre><code class="javascript">// 1.匿名函数在对象中的应用var obj = {  name: &quot;陈贤云&quot;,  age: 18,  // 2.此处函数没有名字，但是前面有规定  sayHello:function(){    console.log(&quot;哈哈哈&quot;);  }}// 3.调用这个方法obj.sayHello()</code></pre><h2 id="3-函数表达式在函数上的应用"><a href="#3-函数表达式在函数上的应用" class="headerlink" title="3.函数表达式在函数上的应用"></a>3.函数表达式在函数上的应用</h2><pre><code class="javascript">// 函数表达式上面的应用var func = function(){  //上面这个函数没有名字，但是有变量名字为func  console.log(&quot;func打印了&quot;);}func()</code></pre><h2 id="4-回调函数的方式"><a href="#4-回调函数的方式" class="headerlink" title="4.回调函数的方式"></a>4.回调函数的方式</h2><pre><code class="javascript">// 4.回调函数的方式setInterval( function(){  console.log(&quot;哈哈哈&quot;);}, 1000)</code></pre><h2 id="5-返回函数的方式"><a href="#5-返回函数的方式" class="headerlink" title="5.返回函数的方式"></a>5.返回函数的方式</h2><pre><code class="javascript">function test(){  // 这里返回一个函数，返回的就是一个匿名函数 return function(){   return &quot;哈哈&quot; }}// 调用函数里面返回的函数console.log(test()());test()</code></pre><h2 id="6-模仿块级作用域"><a href="#6-模仿块级作用域" class="headerlink" title="6.模仿块级作用域"></a>6.模仿块级作用域</h2><ul><li>演示的是没有函数作用域的情况<pre><code class="javascript">if(1 === 1){// a为全局变量var b = 1}console.log(b)//b = 1,如果有函数作用域的话输出为undifined</code></pre></li></ul><p>for(var b = 1; b &lt; 3;b++){<br>  console.log(“当前的变量为：”+ b);<br>}</p><p>console.log(“执行完之后的b:”+b);</p><pre><code>* 用匿名函数（相当于闭包的方式来进行模拟）```javascriptfunction func(){  (function(){    var a = 1  })()  // 报错，not undifine  console.log(a);}// 报错，没法访问函数内部的参数func().a</code></pre><h1 id="以上就是闭包和匿名函数的区别"><a href="#以上就是闭包和匿名函数的区别" class="headerlink" title="以上就是闭包和匿名函数的区别"></a>以上就是闭包和匿名函数的区别</h1><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 基本语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器端常见的存储技术以及区别</title>
      <link href="/2020/07/17/fontend/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/17/fontend/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-常见的浏览器端存储技术"><a href="#1-常见的浏览器端存储技术" class="headerlink" title="1.常见的浏览器端存储技术"></a>1.常见的浏览器端存储技术</h1><h2 id="1-1-cookie-sessionStorage-localStorage"><a href="#1-1-cookie-sessionStorage-localStorage" class="headerlink" title="1.1 cookie sessionStorage localStorage"></a>1.1 cookie sessionStorage localStorage</h2><ul><li>这是主要的几种前端存储数据的几种技术<h1 id="2-有什么不同"><a href="#2-有什么不同" class="headerlink" title="2.有什么不同"></a>2.有什么不同</h1><pre><code class="java">              是否同源            作用                大小            相同点                生命周期cookie            是         网站为了标识用户身份       4k              字符串类型k-v对       在没设置过期和删除就一直在浏览器中</code></pre></li></ul><p>sessionStorage    是         存储比cookie大点的数据     5m+             …..               在前端与后台进行会话的过程中，一直存在<br>localStorage      是         跟sessionStorage差不多     5m+             ….                除非手动删除，不然不会丢失</p><pre><code>* 上面就是我参照我学的一些东西进行的归纳和总结---</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> sessionStorage </tag>
            
            <tag> localStorage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序算法</title>
      <link href="/2020/07/11/arithmtic/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/11/arithmtic/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-选择排序的思想"><a href="#1-选择排序的思想" class="headerlink" title="1.选择排序的思想"></a>1.选择排序的思想</h1><ul><li>跟冒泡排序相似，选择排序从下标i=0开始，j=0开始后面元素依次向后进行遍历，如果存在一个nums[j] &gt; nums[i] 就进行交换（当然这是递减的一个数列），<h1 id="2-具体代码实现"><a href="#2-具体代码实现" class="headerlink" title="2.具体代码实现"></a>2.具体代码实现</h1><pre><code class="java">package com.cxy.SortingAlgorithm;</code></pre></li></ul><p>/**</p><ul><li>选择排序</li><li>思想：</li><li>第一次从下标为0的开始下标为0的这个数与后面的n-1个进行比较；找出最小或者最大的放在下标为0的这个位置；第二次从下标为1的开始比较；查询剩下的最大或者最小值；放在</li><li>下标为1的位置；以此类推；直到排序完成</li><li>/<br>public class SelectSort {</li></ul><p>  int[] arr = {1,2,4,2,0,7,3,3};<br>  public int[] bubbleSort(){<br>    for(int i = 0 ; i&lt;arr.length ;i++){<br>      for(int j = i; j &lt; arr.length; j++){<br>        //就只是这里的循环条件不同而已，判断条件也不相同<br>        if(arr[j] &lt; arr[i]){<br>          swap(arr,i,j);<br>        }<br>      }<br>    }<br>    return arr;<br>  }</p><p>  public void swap(int[] nums, int index1,int index2){<br>    nums[index1] = nums[index1] ^ nums[index2];<br>    nums[index2] = nums[index1] ^ nums[index2];<br>    nums[index1] = nums[index2] ^ nums[index1];<br>  }<br>  public static void main(String[] args) {<br>    SelectSort sort = new SelectSort();</p><pre><code>int[] bubbleSort = sort.bubbleSort();for (int i : bubbleSort) {  System.out.println(i);}</code></pre><p>  }<br>}</p><pre><code>---</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序算法</title>
      <link href="/2020/07/11/arithmtic/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/11/arithmtic/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-冒泡排序是什么"><a href="#1-冒泡排序是什么" class="headerlink" title="1 冒泡排序是什么"></a>1 冒泡排序是什么</h1><ul><li>根据名字我们就可以猜到，什么东西才能冒泡，是不是这个东西比较特别才能被冒泡，所以这个算法就是比较相邻两个数字的大小，如果谁大，就进行位置的互换，互换后的第一次排列肯定最左边或者最右边是最小或者最大的，依次这样循环数组的长度-1次，就可以得到最终的结果了<h1 id="2-采用数组来进行排序"><a href="#2-采用数组来进行排序" class="headerlink" title="2 采用数组来进行排序"></a>2 采用数组来进行排序</h1></li><li>需要注意的就是数组的下标不要越界，外层循环肯定是控制要有多少次比较，内层循环是判断每一次是否需要进行数字的交换<h1 id="3-具体代码如下"><a href="#3-具体代码如下" class="headerlink" title="3 具体代码如下"></a>3 具体代码如下</h1><pre><code class="java"></code></pre></li></ul><p>package com.cxy.SortingAlgorithm;</p><p>/**</p><ul><li>冒泡排序</li><li>思想：依次比较两个相邻的数字，如果后面数比前面的数大，就交换这两个数，依次循环下去</li><li></li><li>/<br>public class BubbleSort {</li></ul><p>  int[] arr = {1,2,4,2,0,7,3,3};<br>  public int[] bubbleSort(){<br>    for(int i = 0 ; i&lt;arr.length-1 ;i++){<br>      for(int j = 0; j &lt; arr.length-1; j++){<br>        if(arr[j] &gt; arr[j+1]){<br>          swap(arr,j,j+1);<br>        }<br>      }<br>    }<br>    return arr;<br>  }</p><p>  public void swap(int[] nums, int index1,int index2){<br>    nums[index1] = nums[index1] ^ nums[index2];<br>    nums[index2] = nums[index1] ^ nums[index2];<br>    nums[index1] = nums[index2] ^ nums[index1];<br>  }</p><p>  public static void main(String[] args) {<br>    BubbleSort sort = new BubbleSort();<br>    int[] newarr = {1,2,3};<br>    int[] bubbleSort = sort.bubbleSort();<br>    for (int i : bubbleSort) {<br>      System.out.println(i);<br>    }<br>  }<br>}</p><pre><code>---</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 冒泡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie_sessionStorage_localStorage的区别 </title>
      <link href="/2020/07/10/fontend/cookie-sessionStorage-localStorage%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/10/fontend/cookie-sessionStorage-localStorage%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1 cookie"></a>1 cookie</h2><ul><li>cookie主要是服务器来设置，前端存储，存储大小为4k,主要是保存用户的一些登录信息，每次用户登录的时候都会拿这个cookie去服务器比对是否过期，只能被同源的请求访问到<h2 id="2-sessionStorage"><a href="#2-sessionStorage" class="headerlink" title="2 sessionStorage"></a>2 sessionStorage</h2></li><li>sessionStorage主要是从后端session演化而来的，主要是保存服务器与前端保持会话中的一些信息，大小为5m左右，也是同源的请求才能被访问到，如果浏览器关闭，就代表会话结束<h2 id="3-localStorage"><a href="#3-localStorage" class="headerlink" title="3 localStorage"></a>3 localStorage</h2></li><li>localStorage是存储用户的的信息，与sessionStorage不同的是，只有通过手动删除的办法才能让它在前端页面中删除。大小5m ，同样也是同源请求才能被访问</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端存储 </tag>
            
            <tag> cookie </tag>
            
            <tag> sessionStorage </tag>
            
            <tag> localStorage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片居中transform和margin的关系</title>
      <link href="/2020/07/09/fontend/%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%ADtransform%E5%92%8Cmargin%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2020/07/09/fontend/%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%ADtransform%E5%92%8Cmargin%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="图片居中transform和margin的用法"><a href="#图片居中transform和margin的用法" class="headerlink" title="图片居中transform和margin的用法"></a>图片居中transform和margin的用法</h1><h2 id="1-transfrom是相对自己本身的宽度进行居中"><a href="#1-transfrom是相对自己本身的宽度进行居中" class="headerlink" title="1.transfrom是相对自己本身的宽度进行居中"></a>1.transfrom是相对自己本身的宽度进行居中</h2><ul><li>transfrom: -50%</li><li><strong>表示向左移动自己本身的一半*</strong><h2 id="2-margin是相对其父元素的宽度进行移动"><a href="#2-margin是相对其父元素的宽度进行移动" class="headerlink" title="2.margin是相对其父元素的宽度进行移动"></a>2.margin是相对其父元素的宽度进行移动</h2></li><li>margin-left: -50%;</li><li><strong>移动相对父元素的一半*</strong></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片居中 </tag>
            
            <tag> transform </tag>
            
            <tag> margin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的数据类型有哪些</title>
      <link href="/2020/07/09/fontend/js%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
      <url>/2020/07/09/fontend/js%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="js中的基本数据类型"><a href="#js中的基本数据类型" class="headerlink" title="js中的基本数据类型"></a>js中的基本数据类型</h1><h2 id="1-js中的基本数据类型主要有6种"><a href="#1-js中的基本数据类型主要有6种" class="headerlink" title="1 js中的基本数据类型主要有6种"></a>1 js中的基本数据类型主要有6种</h2><ul><li>undifined</li><li>Null </li><li>String </li><li>Number </li><li>Boolean</li><li>Symbol–&gt;ES6出现的语法这是一种特殊的数据类型<h2 id="2-如果想要在js中判断变量的类型，可以用typeof进行判断"><a href="#2-如果想要在js中判断变量的类型，可以用typeof进行判断" class="headerlink" title="2 如果想要在js中判断变量的类型，可以用typeof进行判断"></a>2 如果想要在js中判断变量的类型，可以用typeof进行判断</h2><h2 id="3-null，undifined-NaN-symbol-的区别和联系"><a href="#3-null，undifined-NaN-symbol-的区别和联系" class="headerlink" title="3 null，undifined, NaN, symbol, 的区别和联系"></a>3 null，undifined, NaN, symbol, 的区别和联系</h2><h3 id="3-1-null"><a href="#3-1-null" class="headerlink" title="3.1 null"></a>3.1 null</h3></li><li>我的理解就是对象为null，栈区没有引用指向内存地址，指向的是一个空区域，也可以理解为对象为空<h3 id="3-2-undifined"><a href="#3-2-undifined" class="headerlink" title="3.2 undifined"></a>3.2 undifined</h3></li><li>表示声明了变量但是没有给这个变量赋值,它是js中的一个全局属性<h3 id="3-3-NaN"><a href="#3-3-NaN" class="headerlink" title="3.3 NaN"></a>3.3 NaN</h3></li><li>NaN 是一种特殊的类型（Not A Number）是一种特殊的Number类型<h3 id="3-3-symbol"><a href="#3-3-symbol" class="headerlink" title="3.3 symbol"></a>3.3 symbol</h3></li><li>这个我基本上没怎么用到过，gg了一下，用来创建匿名的对象属性<pre><code class="js">//通过这种方法来进行创建这个对象Symbol(&quot;hahaha &quot;)</code></pre><h1 id="js中的其他数据类型"><a href="#js中的其他数据类型" class="headerlink" title="js中的其他数据类型"></a>js中的其他数据类型</h1><h2 id="4-引用数据类型（Object-Array）"><a href="#4-引用数据类型（Object-Array）" class="headerlink" title="4 引用数据类型（Object Array）"></a>4 引用数据类型（Object Array）</h2></li><li>他们的存储方式是通过内存地址进行存储的,如下的内存图所示</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/9/5/16d0049fb3a7841b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p><ul><li>内存地址存储在堆区里面，栈里面保存的是堆内存空间内的引用值，也就是对应对象的内存地址</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Shiro安全框架</title>
      <link href="/2020/07/08/springboot/SpringBoot%E6%95%B4%E5%90%88Shiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/07/08/springboot/SpringBoot%E6%95%B4%E5%90%88Shiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="SpringBoot整合shiro"><a href="#SpringBoot整合shiro" class="headerlink" title="SpringBoot整合shiro"></a>SpringBoot整合shiro</h1><ul><li><p>前面我们介绍了spring security与SpringBoot项目的整合，今天我们就来整合shiro</p><h2 id="1-shiro框架是什么"><a href="#1-shiro框架是什么" class="headerlink" title="1.shiro框架是什么"></a>1.shiro框架是什么</h2></li><li><p>我们来看看官网是怎么解释的，这几个对象是比较重要的，关系我还需要理解一下，现在还不是特别的理解</p></li><li><p>1.realm对象</p></li><li><p>2.DefaultWebSecurityManager</p></li><li><p>3.ShiroFilterFactoryBean</p><h2 id="2-demo的整体结构"><a href="#2-demo的整体结构" class="headerlink" title="2.demo的整体结构"></a>2.demo的整体结构</h2></li><li><p>整合在SpringBoot中，如下</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/22769532-13bbfd81beb0bd91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong><em>感觉是不是跟springsecurity的有点像，其实两者本质上是一致的</em></strong></p><p>最重要的是官网上的这个图，一定要理解他，我们就可以成功的编写我们的代码</p><h2 id="3-引入依赖-这个非常的重要"><a href="#3-引入依赖-这个非常的重要" class="headerlink" title="3.引入依赖(这个非常的重要)"></a>3.引入依赖(这个非常的重要)</h2><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;  &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;  &lt;version&gt;1.5.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="4-配置ShiroConfig类"><a href="#4-配置ShiroConfig类" class="headerlink" title="4.配置ShiroConfig类"></a>4.配置ShiroConfig类</h2><pre><code class="java">package com.cxy.config;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.LinkedHashMap;import java.util.Map;@Configurationpublic class ShiroConfig {  //主要有三大对象需要整合进来  //1.shiroFilterFactoryBean  //2.DefaultWebSecurityManager  @Bean  public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;getDefaultWebSecurityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager){    //设置安全管理器    ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();    bean.setSecurityManager(defaultWebSecurityManager);    /**     * 添加shiro的内置过滤器     *     *///    anoo: 无需认证就可以访问，//    authc: 认证了才能进行访问//    user： 必须拥有记住我功能才能用//    Parm： 拥有某个资源的权限才能进行访问//    role: 拥有某个权限才能访问    Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();//    1.需要授权才能访问//    map.put(&quot;/toIndex&quot;,&quot;authc&quot;);//    map.put(&quot;/toCatagroy&quot;,&quot;authc&quot;);//    2.无须授权就可以访问    map.put(&quot;/toIndex&quot;, &quot;authc&quot;);    //3.拦截页面    bean.setFilterChainDefinitionMap(map);    bean.setLoginUrl(&quot;/toLogin&quot;);    return bean;  }  @Bean  public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm realm){    DefaultWebSecurityManager manager = new DefaultWebSecurityManager();    //关联userRealm    manager.setRealm(realm);    return manager;  }  //3.创建realm对象，需要自定义类  @Bean  public UserRealm userRealm(){    return new UserRealm();  }}/***这个是从下往上进行配置的，主要有这几个主要的对象1.realm对象2.DefaultWebSecurityManager3.ShiroFilterFactoryBean*/</code></pre><h2 id="4-配置UserRealm对象"><a href="#4-配置UserRealm对象" class="headerlink" title="4.配置UserRealm对象"></a>4.配置UserRealm对象</h2><pre><code class="java">package com.cxy.config;import com.cxy.pojo.User;import com.cxy.service.UserService;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.springframework.beans.factory.annotation.Autowired;public class UserRealm  extends AuthorizingRealm {  @Autowired  UserService userService;  //授权  @Override  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {    System.out.println(&quot;执行了授权=》doGetAuthorizationInfo&quot;);    return null;  }  //认证  @Override  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {    System.out.println(&quot;执行了认证=》doGetAuthenticationInfo&quot;);//    String username = &quot;root&quot;;//    String password = &quot;123456&quot;;//    将传递过来的token转换成获得令牌的token    UsernamePasswordToken userToken = (UsernamePasswordToken) authenticationToken;   User user = userService.queryUserByStringName(userToken.getUsername());    if(user == null){      //没有这个人      return null;//return null 的作用是返回到配置信息里面的异常里面    }//    if(!username.equals(userToken.getUsername())){//      return null;//    }    return new SimpleAuthenticationInfo(&quot;&quot;,user.getPassword(),&quot;&quot;);  }}</code></pre><h2 id="5-IndexController的请求"><a href="#5-IndexController的请求" class="headerlink" title="5.IndexController的请求"></a>5.IndexController的请求</h2><pre><code class="java">package com.cxy.controller;import com.cxy.pojo.User;import com.cxy.service.UserService;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.subject.Subject;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.List;@Controllerpublic class IndexController {  @Autowired  private UserService userService;  @RequestMapping({&quot;/&quot;,&quot;/index&quot;,&quot;index.html&quot;})  public String toIndex(Model model){    model.addAttribute(&quot;msg&quot;, &quot;hello,shiro&quot;);    return &quot;index&quot;;  }  @RequestMapping(&quot;/toIndex&quot;)  public String toIndex1(Model model){    model.addAttribute(&quot;msg&quot;, &quot;hello,首页&quot;);    return &quot;/user/toIndex&quot;;  }  @RequestMapping(&quot;/toCatagroy&quot;)  public String toIndex2(Model model){    model.addAttribute(&quot;msg&quot;, &quot;hello,shiro&quot;);    return &quot;/user/toCatagroy&quot;;  }  @RequestMapping(&quot;/toLogin&quot;)  public String toLogin(Model model){    model.addAttribute(&quot;msg&quot;, &quot;hello,shiro&quot;);    return &quot;login&quot;;  }  @RequestMapping(&quot;/login&quot;)  public String login(String username,String password ,boolean rememberMe ,Model model){    Subject subject = SecurityUtils.getSubject();    UsernamePasswordToken token = new UsernamePasswordToken(username,password,rememberMe);    System.out.println(username + &quot;+&quot; +password);    try{//      用户名判断成功      subject.login(token);      return &quot;index&quot;;    }catch (UnknownAccountException e){      model.addAttribute(&quot;msg&quot;, &quot;没有此账户&quot;);      return &quot;login&quot;;    }catch (IncorrectCredentialsException e){      model.addAttribute(&quot;msg&quot;, &quot;密码错误&quot;);      return &quot;login&quot;;    }  }  @ResponseBody  @RequestMapping(&quot;/test&quot;)  public List&lt;User&gt; test(Model model){    model.addAttribute(&quot;msg&quot;, &quot;hello,shiro&quot;);    User user = new User();    user.setName(&quot;cxy&quot;);    List&lt;User&gt; list = userService.queryUserByName(user);    return list;  }}</code></pre><pre><code>---</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端安全 </tag>
            
            <tag> 授权认证 </tag>
            
            <tag> shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-算法-位运算实现的快速排序算法</title>
      <link href="/2020/07/08/arithmtic/22-%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/08/arithmtic/22-%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="排序算法用异或实现"><a href="#排序算法用异或实现" class="headerlink" title="排序算法用异或实现"></a>排序算法用异或实现</h1><h2 id="1-什么是异或"><a href="#1-什么是异或" class="headerlink" title="1.什么是异或"></a>1.什么是异或</h2><ul><li>异或就是当两个数转换成二进制后，进行位运算，如果对应位相同就为0，不同就为1</li><li>举例如下<pre><code class="js">//1.a=1 b=2//2.对应的a转换成二进制位0 1； b转换成二进制为 1 0//3.如果将a^b的值用c二进制保存起来就是c --&gt; 1 1//4.我们将c异或其中任意一个数，得到的就是与之对应的另外一个数//5 比如c^a  得到的是b的值，</code></pre></li></ul><p>//原理就是利用异或的特点：两数异或后的结果再异或其中一数，得到的是另外一个数字</p><p>//验证代码如下</p><p>var a = 1<br>  var b= 2<br>  console.log(“交换前的a:”+ a,”交换前的b:”+b)<br>  //a存储的是a^b的中间值<br>  a = a^b<br>  //用a^b的中间值再来^ b，得到的是a,将a赋值给b<br>  b = a^b<br>  //b保存的是a的值，b^a，实际上是a^ 第一行的a保存的中间值，b^a————》得到b，再将b的值赋值给a<br>  a = b^a<br>  console.log(“交换后的a:”+ a,”交换后的b:”+b)</p><pre><code>* 结果如下![image.png](https://upload-images.jianshu.io/upload_images/22769532-c2bc2992b530574d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)## 2.下面就开始进入正题，快速排序位运算```jsconst arr = [1,2,5,7,2,3,5]  let len = arr.length  let i = 0  var j = 0  while(i &lt; len){    //外层循环遍历第一行    j = i    while(j &lt; len){      //内层循环遍历i后面的元素，查看是否有比当前元素小的，有的话就交换数据      if(arr[j] &lt; arr[i]){        arr[i] = arr[i] ^ arr[j]        arr[j] = arr[i] ^ arr[j]        arr[i] = arr[j] ^ arr[i]       }      j++    }    i++  }  console.log(arr.toString())</code></pre><ul><li>通过这个题，可以提高原有选择排序的一个效率，位运算是比创建一个新的中间值来保存变量效率要更高。这里也可以回忆一下快速排序的一个实现方式</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 异或 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合SpringSecurity</title>
      <link href="/2020/07/08/springboot/SpringBoot%E6%95%B4%E5%90%88SpringSecurity/"/>
      <url>/2020/07/08/springboot/SpringBoot%E6%95%B4%E5%90%88SpringSecurity/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="SpringSecurity整合到SpringBoot项目中"><a href="#SpringSecurity整合到SpringBoot项目中" class="headerlink" title="SpringSecurity整合到SpringBoot项目中"></a>SpringSecurity整合到SpringBoot项目中</h1><ul><li>首先创建的项目如图所示</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/22769532-e2a9b53c96c8d1fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="1-在pom-xml中导入SpringSecurity的依赖"><a href="#1-在pom-xml中导入SpringSecurity的依赖" class="headerlink" title="1.在pom.xml中导入SpringSecurity的依赖"></a>1.在pom.xml中导入SpringSecurity的依赖</h2><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="2-导入thymeleaf模板引擎和静态文件"><a href="#2-导入thymeleaf模板引擎和静态文件" class="headerlink" title="2.导入thymeleaf模板引擎和静态文件"></a>2.导入thymeleaf模板引擎和静态文件</h2><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>静态资源链接在这儿<br>链接：<a href="https://pan.baidu.com/s/1D9N9V-lAmKVR0mwhHuOW2w" target="_blank" rel="noopener">https://pan.baidu.com/s/1D9N9V-lAmKVR0mwhHuOW2w</a><br>提取码：rhl8</li><li>将他放到静态文件夹–&gt;static中即可</li></ul><h2 id="3-编写后端controller"><a href="#3-编写后端controller" class="headerlink" title="3.编写后端controller"></a>3.编写后端controller</h2><pre><code class="java">package com.cxy.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class RouterController {  @RequestMapping(value = {&quot;/index&quot;,&quot;/&quot;})  public String index(){    return &quot;index&quot;;  }  @RequestMapping(value = {&quot;/toLogin&quot;})  public String toLogin(){    return &quot;/views/login&quot;;  }  // 根据id和level获取不同的控制访问路径   @RequestMapping(&quot;/level1/{id}&quot;)  public String toLevel1(@PathVariable(&quot;id&quot;) int id){    return &quot;/views/level1/&quot;+id;  }  @RequestMapping(&quot;/level2/{id}&quot;)  public String toLevel2(@PathVariable(&quot;id&quot;) int id){    return &quot;/views/level2/&quot;+id;  }  @RequestMapping(&quot;/level3/{id}&quot;)  public String toLevel3(@PathVariable(&quot;id&quot;) int id){    return &quot;/views/level3/&quot;+id;  }}</code></pre><h2 id="4-编写配置文件用于映射请求以及用户登录状态，查看不同的权限"><a href="#4-编写配置文件用于映射请求以及用户登录状态，查看不同的权限" class="headerlink" title="4.编写配置文件用于映射请求以及用户登录状态，查看不同的权限"></a>4.编写配置文件用于映射请求以及用户登录状态，查看不同的权限</h2><ul><li>这个文件夹在config下面</li></ul><pre><code class="java">package com.cxy.config;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter {//  授权 这里是链式编程，跟前端中的promise函数有点相像  @Override  protected void configure(HttpSecurity http) throws Exception {    //首页所有人可以访问，功能页具有权限的才能进行访问    http.authorizeRequests().antMatchers(&quot;/&quot;)            .permitAll()            .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)            .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)            .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);    //关闭默认的cfrs防止网站攻击  登出失败的这个    http.csrf().disable();    //跳转到内置写好的页面 添加前端表单上的username和password属性的别名    http.formLogin().loginPage(&quot;/toLogin&quot;).loginProcessingUrl(&quot;/login&quot;)            .usernameParameter(&quot;user&quot;)            .passwordParameter(&quot;pwd&quot;);    //开启注销功能    http.logout().logoutSuccessUrl(&quot;/&quot;);    //开启记住我功能    http.rememberMe().rememberMeParameter(&quot;remember&quot;);  }//  认证//  要进行密码进行加密//  使用spring security中的password编码格式  @Override  protected void configure(AuthenticationManagerBuilder auth) throws Exception {    //这里应该是从数据库中查找数据    auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())            .withUser(&quot;cxy&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;)    .and()    .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)    .and()    .withUser(&quot;chest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;);  }}</code></pre><h2 id="5-开启spring-boot项目，访问首页，进入登录页"><a href="#5-开启spring-boot项目，访问首页，进入登录页" class="headerlink" title="5.开启spring boot项目，访问首页，进入登录页"></a>5.开启spring boot项目，访问首页，进入登录页</h2><ul><li>页面地址：<a href="http://localhost:8080/login页面如下，这个页面是spring" target="_blank" rel="noopener">http://localhost:8080/login页面如下，这个页面是spring</a> boot做授权的时候默认的一个页面，我们页可以自定义这个页面</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/22769532-bdb5e66fc0ad8455.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="5-1因为写了chest来宾用户只有VIP1-的一个权限，所以登录之后只能进行操作VIP1-相关的内容"><a href="#5-1因为写了chest来宾用户只有VIP1-的一个权限，所以登录之后只能进行操作VIP1-相关的内容" class="headerlink" title="5.1因为写了chest来宾用户只有VIP1 的一个权限，所以登录之后只能进行操作VIP1 相关的内容"></a>5.1因为写了chest来宾用户只有VIP1 的一个权限，所以登录之后只能进行操作VIP1 相关的内容</h3><ul><li>level1的操作是正常的</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/22769532-6e7d56060540309e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>level2的操作就是没有授权的</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/22769532-ca280edb2ec55bba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="这就做到了不同的用户操作不同的内容，而且显示的东西也是不一样的"><a href="#这就做到了不同的用户操作不同的内容，而且显示的东西也是不一样的" class="headerlink" title="这就做到了不同的用户操作不同的内容，而且显示的东西也是不一样的"></a>这就做到了不同的用户操作不同的内容，而且显示的东西也是不一样的</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端安全 </tag>
            
            <tag> 授权认证 </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21-算法-(排序算法)-数组合并并排序</title>
      <link href="/2020/07/07/arithmtic/21-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/07/07/arithmtic/21-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="合并排序数组"><a href="#合并排序数组" class="headerlink" title="合并排序数组"></a>合并排序数组</h1><h2 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h2><ul><li>Input:<ul><li>A = [1,2,3,0,0,0], m = 3</li><li>B = [2,5,6],       n = 3</li><li></li><li>Output: [1,2,2,3,5,6]</li></ul></li></ul><p>函数的参数如下</p><pre><code class="java">//输入参数为两个数组加上两数组的分别长度，而且A数组是完全可以装下B的public void merge(int[] A, int m, int[] B, int n) {}</code></pre><h2 id="解题思路一"><a href="#解题思路一" class="headerlink" title="解题思路一"></a>解题思路一</h2><p>可以先将第二个数组加入到第一个数组的末尾，然后对整个数组A进行冒泡排序升序排列。</p><pre><code class="java">//核心代码如下package com.cxy.SortingAlgorithm;/** *You are given two sorted arrays, A and B, where A has a large enough buffer at the end to hold B. Write a method to merge B into A in sorted order. * * Initially the number of elements in A and B are m and n respectively. * * Example: * * Input: * A = [1,2,3,0,0,0], m = 3 * B = [2,5,6],       n = 3 * * Output: [1,2,2,3,5,6] * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/sorted-merge-lcci * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class MergeSortArray {  /**   * 思路就是先将B中后面的数据存到A中，然后再进行排序   */  //将两个数组进行合并然后返回  private int[] sumArr(int[] A, int m,int[] B,int n){    if(m == 0 &amp;&amp; n == 0){return A;}    if(m == 0){return B;}    if(n == 0){return A;}    int index = m;    int j = 0;    for(; index &lt;= m+n-1; index++){      A[index] = B[j];//      System.out.println(A[n]);      j++;    }    return A;  }  public void merge(int[] A, int m, int[] B, int n) {    //j是指向的B中的下标    int[] sumArr = sumArr(A,m, B,n);    //对数据进行排序,采用冒泡排序进行降序排列    for(int i = 0;i&lt;sumArr.length-1;i++){      for(int j = i+1; j&lt;sumArr.length-1; j++){        System.out.println(sumArr[i] +&quot; -- &quot;+ sumArr[j]);        if(sumArr[i] &gt; sumArr[j]){          int temp = sumArr[i];          sumArr[i] = sumArr[j];          sumArr[j] = temp;        }      }    }  }  public static void main(String[] args) {    int[] A = new int[] {0};    int[] B = new int[] {2};    new MergeSortArray().merge(A, 0,B, 1);  }}</code></pre><h2 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h2><ul><li>因为两个数组都是排好序的，双指针都指向数组的头的话，每次 比较都要移动数组的后面全部，换一种思路，从后面进行指向，每次比较尾部的两个数据大小 ，大的就放入A的尾部，依次这样循环，<strong><em>这里要注意当A数组为空的时候，直接将B的数据全部搬到A里面就可以了。</em></strong><pre><code class="java">class Solution {public void merge(int[] A, int m, int[] B, int n) {  //两个数组中的下标  int i = m - 1;  int j = n - 1;  //新的合并的数组  int index = m + n-1;  while(j &gt;= 0){    //如果数组A为空，直接将数组B中的内容加到    if(i &lt; 0 || A[i] &lt; B[j]){      A[index] = B[j];      j--;    }else{      A[index] = A[i];      i--;    }    index--;  }}}</code></pre>这里的双指针指向的分别是数组的尾部，然后依次比较大小，特别要注意的是A可能是为空的，也就是没有前面的元数据，所以直接在while里面第一次判断直接将B加入到A中，这个是这道题的重要的一点。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 逆向循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-前端布局三栏实现</title>
      <link href="/2020/07/07/fontend/04-%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E4%B8%89%E6%A0%8F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/07/07/fontend/04-%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E4%B8%89%E6%A0%8F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前端三栏布局"><a href="#前端三栏布局" class="headerlink" title="前端三栏布局"></a>前端三栏布局</h1><h2 id="1-实现的效果是左右定宽，中间自适应"><a href="#1-实现的效果是左右定宽，中间自适应" class="headerlink" title="1.实现的效果是左右定宽，中间自适应"></a>1.实现的效果是左右定宽，中间自适应</h2><h2 id="2-float实现"><a href="#2-float实现" class="headerlink" title="2.float实现"></a>2.float实现</h2><ul><li>实现原理<br>左右浮动，中间用margin进行分隔<br>```css</li><li>{<pre><code> margin: 0; padding: 0;</code></pre>   }<br>   .main{<pre><code> /* display: flex; */ height: 100px;</code></pre>   }<br>   .left{<pre><code> float: left; width: 100px; height: 100%; background-color: red;</code></pre>   }<br>   .right{<pre><code> float: right; height: 100%; width: 200px; background-color: yellowgreen;</code></pre>   }<br>   .center{<pre><code> height: 100%; width: 100%; margin: 0 200px 0 100px; background-color: aqua;</code></pre>   }<pre><code></code></pre></li></ul><h2 id="3-flex"><a href="#3-flex" class="headerlink" title="3.flex"></a>3.flex</h2><pre><code class="css">/* 用flex布局实现 */.main{  display: flex;  height: 100px;}.left{  width: 100px;  background-color: red;}.center{  flex: 1;  background-color: yellow;}.right{  width: 100px;  background-color: blue;}</code></pre><ul><li>在目前看来，用浮动和flex布局是居多的，如果后我发现了新的布局方式，我会第一时间更新到我的博客上，总而言之，言而总之，<br>万物皆可flex(老ie😀了)</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 布局 </tag>
            
            <tag> 三栏布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-前端两栏布局</title>
      <link href="/2020/07/07/fontend/03-%E5%89%8D%E7%AB%AF%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
      <url>/2020/07/07/fontend/03-%E5%89%8D%E7%AB%AF%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前端样式布局两栏布局"><a href="#前端样式布局两栏布局" class="headerlink" title="前端样式布局两栏布局"></a>前端样式布局两栏布局</h1><hr><h2 id="1-两栏布局用在何处"><a href="#1-两栏布局用在何处" class="headerlink" title="1.两栏布局用在何处"></a>1.两栏布局用在何处</h2><ul><li>左边栏固定，右边栏根据视口进行自适应<h2 id="2-进行两栏布局的方式方法有哪些"><a href="#2-进行两栏布局的方式方法有哪些" class="headerlink" title="2.进行两栏布局的方式方法有哪些"></a>2.进行两栏布局的方式方法有哪些</h2></li><li>2.1 float + margin</li><li>2.2 flex 布局</li><li><strong><em>目前我实际用过的就这两种</em></strong></li></ul><h2 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3.具体实现"></a>3.具体实现</h2><h3 id="3-1-flat-margin"><a href="#3-1-flat-margin" class="headerlink" title="3.1 flat + margin"></a>3.1 flat + margin</h3><pre><code class="css">    /* 第一种实现      left固定宽度左浮动，right 宽度width: auto;     */    .main{      width: 100%;      height: 1000px;      background-color: #eee;    }    .left{      width: 300px;      height: 100%;      float: left;      background-color: red;    }    .right{      width: auto;      height: 100%;      margin-left: 300px;      background-color: yellow;    } </code></pre><h3 id="3-2flex布局实现"><a href="#3-2flex布局实现" class="headerlink" title="3.2flex布局实现"></a>3.2flex布局实现</h3><pre><code class="css">  .main{    width: 100%;    height: 400px;    background-color: red;    /*开启flex布局，里面的小item会成为一个个的小内容块儿*/    display: flex;  }  .left{    width: 100px;    background-color: violet;  }  .right{    /*设置占比为剩下的100%*/    flex: 1;    background-color: yellowgreen;  }</code></pre><h3 id="3-3flex布局实现"><a href="#3-3flex布局实现" class="headerlink" title="3.3flex布局实现"></a>3.3flex布局实现</h3><pre><code class="css">    .main{      display: flex;      height: 1000px;      background-color: red;    }    .left{      flex-shrink: 0;      flex-grow: 0;      flex-basis: 200px;      background-color: yellowgreen;    }    .right{      flex: auto;      background-color: blue;    }</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 布局 </tag>
            
            <tag> 两栏布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-前端axios网络请求的封装</title>
      <link href="/2020/07/07/fontend/02-%E5%89%8D%E7%AB%AFaxios%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B0%81%E8%A3%85/"/>
      <url>/2020/07/07/fontend/02-%E5%89%8D%E7%AB%AFaxios%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="网络请求axios封装"><a href="#网络请求axios封装" class="headerlink" title="网络请求axios封装"></a>网络请求axios封装</h1><h2 id="1-什么是网络请求"><a href="#1-什么是网络请求" class="headerlink" title="1.什么是网络请求"></a>1.什么是网络请求</h2><p>在进行与后端数据交互的时候，通常需要向后端发送网络请求得到json串，前端通过格式转换进行页面的展示</p><h2 id="2-为什么要使用axios作为网络请求框架"><a href="#2-为什么要使用axios作为网络请求框架" class="headerlink" title="2.为什么要使用axios作为网络请求框架"></a>2.为什么要使用axios作为网络请求框架</h2><p>刚开始纯xhr <strong><em>（XmlHttpRequest）</em></strong> 对象方式进行网络请求的发送，比较麻烦，并且容易产生冗余代码。后来出现了 <strong><em>jquery库中的ajax</em></strong> ，也是一个前端网路数据请求的框架，相比原生的网路请求，ajax进步很大，对xhr进行了进一步的封装，但是出现另外一个问题，那就是容易产生 <strong><em>回调地狱的问题</em></strong> ，如下 <strong><em>极端情况</em></strong></p><pre><code class="js">$.ajax(url1,()=&gt;{  //在发送URL1请求的时候又继续发送请求URL2，代码一直处于回调中  // 这是一种很极端的情况，但有时候超过三层就不再回调了  $.ajax(url2,()=&gt;{  })})</code></pre><h2 id="3-axios解决函数的回调和业务逻辑单独处理"><a href="#3-axios解决函数的回调和业务逻辑单独处理" class="headerlink" title="3.axios解决函数的回调和业务逻辑单独处理"></a>3.axios解决函数的回调和业务逻辑单独处理</h2><h3 id="3-1axios发送请求的方式"><a href="#3-1axios发送请求的方式" class="headerlink" title="3.1axios发送请求的方式"></a>3.1axios发送请求的方式</h3><pre><code class="js">axios(config)axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])</code></pre><h3 id="3-2发送get请求"><a href="#3-2发送get请求" class="headerlink" title="3.2发送get请求"></a>3.2发送get请求</h3><pre><code class="js">import axios from &#39;axios&#39;export default {  name: &#39;#app&#39;  created:{    // 链式调用，.then()处理成功的回调，.catch()处理异常和拦截的数据    axios.get(&#39;http://localhost:8080/getlist&#39;).then(res =&gt; {      console.log(res)    }).catch(error){      console.log(error)    }  }}</code></pre><h3 id="3-3发送并发请求-两个及以上"><a href="#3-3发送并发请求-两个及以上" class="headerlink" title="3.3发送并发请求(两个及以上)"></a>3.3发送并发请求(两个及以上)</h3><pre><code class="js">import axios from &#39;axios&#39;export default {  name: &#39;#app&#39;  created:{    //     axios.all(axios.get(&#39;http://localhost:8080/getlist&#39;,&#39;http:localhost:8080/getUserName&#39;),axios.get(&#39;http://localhost:8080/getusename&#39;),{parms:{type:&#39;sell&#39;,page:1}}).then(axios.spread((res1,res2) =&gt; {      console.log(res1)      console.log(res2)    })  }}</code></pre><h3 id="3-4网络全局配置"><a href="#3-4网络全局配置" class="headerlink" title="3.4网络全局配置"></a>3.4网络全局配置</h3><pre><code class="js">// axios.defaults.baseURL = ‘123.207.32.32:8000’axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’;// 开发过程中很多参数都是相同的，所以把相同的东西抽取出来axios.defaults.baseUrl = &#39;http://localhost:8080/api&#39; export default {  name: &#39;#app&#39;  created:{    // 链式调用，.then()处理成功的回调，.catch()处理异常和拦截的数据    axios.get(&#39;/username&#39;).then(res =&gt; {      console.log(res)    }).catch(error){      console.log(error)    }  }}</code></pre><h2 id="4-让项目发送网路请求更加具有可配置性"><a href="#4-让项目发送网路请求更加具有可配置性" class="headerlink" title="4 让项目发送网路请求更加具有可配置性"></a>4 让项目发送网路请求更加具有可配置性</h2><h3 id="4-1-创建新的axios全局实例"><a href="#4-1-创建新的axios全局实例" class="headerlink" title="4.1 创建新的axios全局实例"></a>4.1 创建新的axios全局实例</h3><pre><code class="js">// 通过axios.create方法传入参数const instance = axios.create({  baseURL: &#39;http://localhost:8080/api&#39;  timeout: 5000  headers:{    // 用于上传form 表单    &#39;Content-Type’] = ‘application/x-www-form-urlencoded&#39;  }})</code></pre><h3 id="4-2-axios配置的升级版本"><a href="#4-2-axios配置的升级版本" class="headerlink" title="4.2 axios配置的升级版本"></a>4.2 axios配置的升级版本</h3><h4 id="网络请求的目录"><a href="#网络请求的目录" class="headerlink" title="网络请求的目录"></a>网络请求的目录</h4><p><img src="https://upload-images.jianshu.io/upload_images/22769532-e88c4785bc0e5e1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="axios-js文件"><a href="#axios-js文件" class="headerlink" title="axios.js文件"></a>axios.js文件</h4><pre><code class="js">//用单独的文件来保存这个文件import originAxios from &#39;axios&#39;export default function request(config) {    //1.创建axios实例    const instance = originAxios.create({        baseURL: &#39;http://152.136.185.210:8000/api/n3&#39;,        timeout: 5000,      }    )    //2.拦截器的使用（request）    instance.interceptors.request.use(config=&gt;{      // console.log(config);      //放行拦截的信息      //1.比如config中的一些信息不符合服务器的要求      //2.比如每次发送网络请求时候，都希望在界面中显示一个请求的图标      //3.某些网络请求(比如登录(token )),必须携带的一些信息。token就是令牌      return config    },err =&gt;{      console.log(err);    })    //3.response拦截的使用    instance.interceptors.response.use(resp=&gt;{      // console.log(resp);      return resp    },err=&gt;{      console.log(err);    })    //3.发送真正的网络请求    return instance(config)}</code></pre><h4 id="detail-js文件-这个就是具体发送网络请求的地方"><a href="#detail-js文件-这个就是具体发送网络请求的地方" class="headerlink" title="detail.js文件 这个就是具体发送网络请求的地方"></a>detail.js文件 这个就是具体发送网络请求的地方</h4><pre><code class="js">import request from &quot;./axios&quot;;export function getDetail(iid) {  return request({    url: &#39;/detail&#39;,    params:{      iid    }  })}export function getRecommends() {  return request({    url: &#39;/recommend&#39;  })}export class Goods {  constructor(itemInfo,columns,service) {    this.title = itemInfo.title    this.price = itemInfo.price    this.oldPrice = itemInfo.oldPrice    this.discount = itemInfo.discountDesc    this.columns = columns    this.services = service    this.desc = itemInfo.desc    this.realPrice = itemInfo.lowNowPrice  }}</code></pre><h4 id="在使用网络请求的地方导入detail-js"><a href="#在使用网络请求的地方导入detail-js" class="headerlink" title="在使用网络请求的地方导入detail.js"></a>在使用网络请求的地方导入detail.js</h4><pre><code class="js">import {getDetail ,getRecommends,Goods} from &quot;network/detail&quot;;</code></pre><h4 id="使用这个网络请求"><a href="#使用这个网络请求" class="headerlink" title="使用这个网络请求"></a>使用这个网络请求</h4><pre><code class="js">getDetail(this.iid).then(res=&gt;{  //1.获取商品数据  const data= res.data.result;  console.log(data)})</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
            <tag> ajax </tag>
            
            <tag> 网路请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-vue中的组件为什么是返回函数</title>
      <link href="/2020/07/06/fontend/01-vue%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0/"/>
      <url>/2020/07/06/fontend/01-vue%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<!-- 头部的title --><hr><h1 id="组件中的data属性为什么返回值是一个函数，而不是对象"><a href="#组件中的data属性为什么返回值是一个函数，而不是对象" class="headerlink" title="组件中的data属性为什么返回值是一个函数，而不是对象"></a>组件中的data属性为什么返回值是一个函数，而不是对象</h1><h2 id="1-组件是高可复用性的"><a href="#1-组件是高可复用性的" class="headerlink" title="1.组件是高可复用性的"></a>1.组件是高可复用性的</h2><p>1.1 如果组件中的data返回的是一个对象，那么其他地方在使用这个组件进行传值的时候，因为传递进来的是一个值引用，而不是一个具体的对象，js中传递的全部是引用，没有达到组件数据的隔离的效果，导致一处数据发生改变，用过相同组件的地方也会产生相应的变化，这是我们不希望发生的。例如下面的例子</p><h2 id="2例子如下"><a href="#2例子如下" class="headerlink" title="2例子如下"></a>2例子如下</h2><pre><code class="js">const obj = {    count:0  }  //注册并挂载到全局的Vue上  Vue.component(&#39;spn&#39;,{    template:`#mycpn`,    data(){      return obj    },    methods:{      increment(){        this.count++      },      decrement(){        this.count--      }    }  })  let app = new Vue({    el: &quot;#app&quot;,  })  //在设计这个vue的时候，考虑到组件之间更改属性的过程中，如果直接更改属性会造成其他用到组件的地方因为前一个数据的变化，后面组件跟着变化的情况  //干脆直接设计成为调用函数，每次调用的时候变量的引用都是不同的，这样每次在进行修改组件属性的时候，其他的组件属性不会发生更改</code></pre><p>上面代码的效果图<br><img src="https://upload-images.jianshu.io/upload_images/22769532-14b9556c3a231a74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上面代码当我点击加号或者减号会出现什么样的结果呢，如下<br><img src="https://upload-images.jianshu.io/upload_images/22769532-c953be3ac4ee7fae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当我点击加号的时候，这两个数字都进行了加1操作，这是我们希望看到的吗，实际工作中我们也是不希望有这样的事儿发生，因为组件是相对封闭的一个空间，他自己里面执行的逻辑不能被其他引用了该组件的操作所影响，那么我们就来研究一下为什么会发生这样的情况。</p><p>首先我们来看一个js代码</p><pre><code class="js">  function getMsg(){    return {      name:&quot;cxy&quot;,      age:18    }   } let obj1 = getMsg(); let obj2 = getMsg(); let obj3 = getMsg(); obj1.name=&quot;coder&quot;  console.log(obj1.name)  console.log(obj2.name)  console.log(obj3.name)</code></pre><p>我调用了三次getMsg()方法，返回了三个对象，我要验证这三个对象是否是属于同一个，我将其中一个对象的属性改了，看其他对象的属性是否会跟着改变，答案我们可以看到，他们是不会改变的，如下<br><img src="https://upload-images.jianshu.io/upload_images/22769532-0e79a278953c39cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这到底是什么原因呢？理解这个问题，我们要首先了解内存模型，在进行方法调用返回对象的时候，每次返回的对象都是从栈空间里面创建的临时变量，也就是一个内存地址，如下<br><img src="https://upload-images.jianshu.io/upload_images/22769532-42e4c55bd2ca3c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snipaste_2020-06-04_08-41-37.png"></p><p>来看一下他的反例</p><pre><code class="js">  //这里直接返回的是临时开辟的一块内存地址，而且地址不会发生改变  const msg = {    name:&quot;cxy&quot;,    age:18  }  function getMsg(){    return msg;  } let obj1 = getMsg(); let obj2 = getMsg(); let obj3 = getMsg(); obj1.name=&quot;coder&quot;  console.log(obj1.name)  console.log(obj2.name)  console.log(obj3.name)</code></pre><p>打印结果<br><img src="https://upload-images.jianshu.io/upload_images/22769532-9bde731ef75d8be6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这又是为什么呢？请看下图</p><p><img src="https://upload-images.jianshu.io/upload_images/22769532-bd8d8e652f273afa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>那么也就解释了为什么data是一个函数，而不是一个对象，是对象的话，就直接返回的同一个内存地址，导致同一组件在不同地方使用，对象属性之间会产生影响。欢迎小伙伴儿指出我理解的不是很正确的地方，喜欢的话可以点赞支持一下，哈哈哈</p>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 内存地址引用 </tag>
            
            <tag> js原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot项目整合mybatis</title>
      <link href="/2020/07/06/springboot/SpringBoot%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88mybatis/"/>
      <url>/2020/07/06/springboot/SpringBoot%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88mybatis/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="SpringBoot整合mybatis"><a href="#SpringBoot整合mybatis" class="headerlink" title="SpringBoot整合mybatis"></a>SpringBoot整合mybatis</h1><p><strong><em>文件的目录结构如下</em></strong><br><img src="https://upload-images.jianshu.io/upload_images/22769532-b8544dcf07c1caec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="1-首先引入mybatis的依赖包，用spring来整合mybatis需要的整合包"><a href="#1-首先引入mybatis的依赖包，用spring来整合mybatis需要的整合包" class="headerlink" title="1. 首先引入mybatis的依赖包，用spring来整合mybatis需要的整合包"></a>1. 首先引入mybatis的依赖包，用spring来整合mybatis需要的整合包</h2><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="2-引入阿里druid数据源"><a href="#2-引入阿里druid数据源" class="headerlink" title="2.引入阿里druid数据源"></a>2.引入阿里druid数据源</h2><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;druid&lt;/artifactId&gt;  &lt;version&gt;1.1.13&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="3-引入mysql连接包"><a href="#3-引入mysql连接包" class="headerlink" title="3.引入mysql连接包"></a>3.引入mysql连接包</h2><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h2 id="4-配置数据库的相关数据"><a href="#4-配置数据库的相关数据" class="headerlink" title="4.配置数据库的相关数据"></a>4.配置数据库的相关数据</h2><pre><code class="properties">spring.datasource.username= rootspring.datasource.password= 123456spring.datasource.url=jdbc:mysql://localhost:3306/springtest?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver&lt;!-- 配置.xml中的别名 --&gt;mybatis.type-aliases-package=classpath:com.cxy.pojo&lt;!-- 扫描mappers.xml文件的地方 --&gt;mybatis.mapper-locations=classpath:mybatis/mappers/*.xml</code></pre><h2 id="5-编写mapper接口操作数据库"><a href="#5-编写mapper接口操作数据库" class="headerlink" title="5.编写mapper接口操作数据库"></a>5.编写mapper接口操作数据库</h2><pre><code class="java">// 这两个接口是非常重要的，一个是识别Mapper用，Repository是用于让Spring识别这个接口，纳入Spring管理@Mapper@Repositorypublic interface UserMapper {  // 核心方法如下  //查询全部用户  List&lt;User&gt; queryAllUser();  //插入用户  int insertUser(User user);  //删除用户  int deleteUserById(int id);  //更新用户  int update(User user);}</code></pre><h2 id="6-编写Mapper操作数据库的xml文件，方便操作数据库"><a href="#6-编写Mapper操作数据库的xml文件，方便操作数据库" class="headerlink" title="6.编写Mapper操作数据库的xml文件，方便操作数据库"></a>6.编写Mapper操作数据库的xml文件，方便操作数据库</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.cxy.mapper.UserMapper&quot;&gt;&lt;!--  添加一个用户进入数据库--&gt;  &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.cxy.pojo.User&quot;&gt;    insert into user(user_id,name,password,user_email) value(    #{user_id},#{name},#{password},#{user_email}    )  &lt;/insert&gt;&lt;!--  根据用户传进来的id进行更新--&gt;  &lt;update id=&quot;update&quot; parameterType=&quot;com.cxy.pojo.User&quot;&gt;    update user set name = #{name} ,password = #{password},user_email=#{user_email}     where user_id = #{user_id}  &lt;/update&gt;&lt;!--  根据id进行删除用户--&gt;  &lt;delete id=&quot;deleteUserById&quot;&gt;    delete from user where user_id = #{id}  &lt;/delete&gt;&lt;!--  查询全部的用户--&gt;  &lt;select id=&quot;queryAllUser&quot; resultType=&quot;com.cxy.pojo.User&quot;&gt;    select * from user  &lt;/select&gt;&lt;/mapper&gt;</code></pre><h2 id="7-测试用例"><a href="#7-测试用例" class="headerlink" title="7.测试用例"></a>7.测试用例</h2><p><strong>编写controller</strong></p><pre><code class="java">/**   * 查询用户   * @return   */  @GetMapping(value = {&quot;/queryAllUser&quot;,&quot;/user&quot;})  public List&lt;User&gt; queryAllUser(){    return userMapper.queryAllUser();  }  // 另外三个是在Test里面进行测试的，增加和更改类似，所以就同一个方法   @Test  void contextLoads() {    User cxy = new User(222, &quot;陈贤云&quot;, &quot;222222&quot;, &quot;mysql&quot;);    // 更改用户    int res = userMapper.update(cxy);    System.out.println(res);    // 删除用户//    int rest = userMapper.deleteUserById(10);//    System.out.println(rest);  }</code></pre><hr><h2 id="这样的话，就可以将mybatis集成到SpringBoo项目中了"><a href="#这样的话，就可以将mybatis集成到SpringBoo项目中了" class="headerlink" title="这样的话，就可以将mybatis集成到SpringBoo项目中了"></a>这样的话，就可以将mybatis集成到SpringBoo项目中了</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-mysql-Timezone设置</title>
      <link href="/2020/07/06/mysql56/01-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E9%92%9F%E8%AE%BE%E7%BD%AE/"/>
      <url>/2020/07/06/mysql56/01-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E9%92%9F%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<hr><p>#想必小伙伴儿们在进行IDEA连接数据库的时候，都会出现下面的问题</p><pre><code class="java">Server returns invalid timezone</code></pre><p>解决办法：<br>cmd进入数据库中，use-&gt;你要使用的哪张表<br>输入以下内容进行查找时区</p><pre><code class="java">show variables like &quot;%time_zone&quot;;</code></pre><p>如果显示的是System，则证明没有选择时区，再输入以下内容选择时区</p><pre><code>set global time_zone = &quot;+8:00&quot;;</code></pre><p>这样我们就可以搞定这个问题了</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法20(递归)-二叉树的深度</title>
      <link href="/2020/07/04/arithmtic/20-%E9%80%92%E5%BD%92/"/>
      <url>/2020/07/04/arithmtic/20-%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>题目：</p><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><p>Given binary tree [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>return its depth = 3.</p><p>给一个二叉树，将他的最大深求出来并且进行输出<br>1.采用递归的思想，停止递归的条件是根节点没有左子树并且没有右子树，就返回0，<br>2.递归做什么事情，递归左子树，递归右子树，找到两个子树深度最大值，再进行加3.返回的就是两个子树深度最大值加1</p><pre><code class="java">package com.cxy.recursive;import com.cxy.linkedtable.TreeNode;import java.util.List;/** * 二叉树的深度优先搜索递归实现 */public class BinaryTreeDepth {  public int maxDepth(TreeNode root) {    if(root == null){return 0;}    int leftDeep = maxDepth(root.left);    int rightDeep = maxDepth(root.right);    return Math.max(leftDeep, rightDeep)+1;  }  public static void main(String[] args){    TreeNode left = new TreeNode(1, null, null);    TreeNode right = new TreeNode(2, null, null);    TreeNode root = new TreeNode(0, left, right);    int depth = new BinaryTreeDepth().maxDepth(root);    System.out.println(depth);  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法19(递归)-有效的括号</title>
      <link href="/2020/07/04/arithmtic/19-%E9%80%92%E5%BD%92/"/>
      <url>/2020/07/04/arithmtic/19-%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>题目：<br>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:</p><p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p><p>一般看到这种比较具有对称性的一般都是可以采用递归思路进行求解的，主要是停止的状态是在什么地方，函数的参数设计，函数返回值以及涉及到里面递归调用的关系，一个小的子问题的理解，怎样理解这一个子问题是一个非常麻烦的事情，在这道题中，每一个()()()这种问题，都是()这种问题的的一个组合问题，在递归函数中，只需要找到函数的一个子解的终止条件，在这里，子解的终止条件就是当左括号和右括号都没有的时候，就可以进行返回操作，还有就是定义这个函数参数是(int left , int right,String item)分别表示，左右括号数量，每一次递归所加进来的字符串是哪种，具体的代码入下</p><pre><code class="java"> //用于存储的集合  List&lt;String&gt; res = new ArrayList&lt;&gt;();  public List&lt;String&gt; generateParenthesis(int n) {    helper(n, n, &quot;&quot;);    return res;  }  private void helper(int left , int right , String curStr){    if(left == 0 &amp;&amp; right == 0 ) {      res.add(curStr);      return;    }    //1.结束条件，即没有左括号，也没有右括号，就返回，并将结果加入res    //2.函数调用,还有左括号，就添加左括号    if(left &gt; 0) {      helper( left - 1, right, curStr + &quot;(&quot; );    }    if(right &gt; left) {      helper(left, right - 1, curStr + &quot;)&quot; );    }  }</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法18(递归)-斐波拉契数列</title>
      <link href="/2020/07/04/arithmtic/18-%E9%80%92%E5%BD%92/"/>
      <url>/2020/07/04/arithmtic/18-%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>题目：<br>The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), for N &gt; 1.<br>Given N, calculate F(N).</p><p>Example 1:</p><p>Input: 2<br>Output: 1<br>Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.<br>Example 2:</p><p>Input: 3<br>Output: 2<br>Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.<br>Example 3:</p><p>Input: 4<br>Output: 3<br>Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</p><p>Note:</p><p>0 ≤ N ≤ 30.</p><p>采用递归的方法，秒解这道题：代码中也有详细的描述</p><pre><code class="Java">public class FibonacciSequence {  //1.函数是用来干什么的：计算f(N)  //2.函数结束条件是什么：当n为0或者为1的时候就应该结束  //3.寻找函数的等式或者给下一层返回的是什么：f(n) = f(n-1) + f(n-2)  public int fib(int N) {    if(N == 0 || N ==1){return N;}    return fib(N-1)+fib(N-2);  }  public static void main(String[] args) {    FibonacciSequence sequence = new FibonacciSequence();    int i = sequence.fib(3);    System.out.println(i);  }}</code></pre><p>做递归题就按照我这种套路来进行做就比较好理解，不要在意递归里面的具体细节，只需关注这个等式，以及停止的一个条件。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fibonacci-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fibonacci-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法17(递归)-反转单链表</title>
      <link href="/2020/07/04/arithmtic/17-%E9%80%92%E5%BD%92/"/>
      <url>/2020/07/04/arithmtic/17-%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>题目描述：<br>Reverse a singly linked list.</p><p>Example:</p><p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>Follow up:</p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><p>采用递归的思路<br>思路：1.不要想递归每一步是怎样完成的，只需要关注递归的一级：每一级可以看做是下面这种情况</p><pre><code>head----&gt;head.next----&gt;null，每一级都是这样的一个小子问题</code></pre><p>  2.递归终结的条件是什么：只有一个节点或者是没有节点了就递归结束</p><p>  3.本级递归需要做的事情是什么：交换两个链表的指向：head.next–&gt;null,head.next.next = head</p><hr><p>下面就是具体的代码实现</p><pre><code class="Java">package com.cxy.linkedtable;/** * Reverse a singly linked list. * * Example: * * Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL * Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL * Follow up: * * A linked list can be reversed either iteratively or recursively. Could you implement both? * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/reverse-linked-list * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class ReverseSLList {  public ListNode reverseList(ListNode head) {    //采用递归调用的方式进行反转，不要在乎内部的细节，关注如下几点    //    1.递归的终止条件：交换两个节点，如果只有一个节点或者是没有节点就可以停止了。    //    2.本级递归需要给下级递归传递什么：给下级传递的就是当前结点的下一个节点    //    3.本次递归做什么： 本次递归需要交换两个节点。    if(head == null || head.next == null){      return head;    }    //移动指针指向    ListNode res = reverseList(head.next);    head.next.next = head;    head.next = null;    return res;  }  public static void main(String[] args) {    ReverseSLList slList = new ReverseSLList();    ListNode l1 = new ListNode(1);    l1.next = new ListNode(2);    l1.next.next = new ListNode(3);    ListNode node = slList.reverseList(l1);    System.out.println(node.toString());  }}</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法16(字符串)-字符串转换倒N进行输出</title>
      <link href="/2020/07/04/arithmtic/16-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/07/04/arithmtic/16-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p>解析：利用取余的方式和取模的取出对应个，十，百，千，位数上具体的字符是什么，取余出来之后再将对应数位的字符与字符数组里的字符串进行对应，找到对应的字符串。然后拼接就可以得到具体的罗马数字，理解这个罗马数字的组成，再利用数字的取余和整除的特点把对应的字符取出来。<br>具体代码如下</p><pre><code class="Java">public class IntToRoman {  public String intToRoman(int num) {    String[] one = new String[] {&quot;&quot; ,&quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot; };    String[] two = new String[] {&quot;&quot; ,&quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot; };    String[] thr = new String[] {&quot;&quot; ,&quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot; };    String[] fou = new String[] {&quot;&quot; ,&quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;};    return fou[num/1000]+ thr[num%1000/100] +two[num%100/10]+ one[num%10];  }  public static void main(String[] args){    IntToRoman toRoman = new IntToRoman();    String s = toRoman.intToRoman(1994);    System.out.println(s);  }}</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法15(字符串)-阿拉伯数字转字符串</title>
      <link href="/2020/07/04/arithmtic/15-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/07/04/arithmtic/15-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p>解析：利用取余的方式和取模的取出对应个，十，百，千，位数上具体的字符是什么，取余出来之后再将对应数位的字符与字符数组里的字符串进行对应，找到对应的字符串。然后拼接就可以得到具体的罗马数字，理解这个罗马数字的组成，再利用数字的取余和整除的特点把对应的字符取出来。<br>具体代码如下</p><pre><code class="java">public class IntToRoman {  public String intToRoman(int num) {    String[] one = new String[] {&quot;&quot; ,&quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot; };    String[] two = new String[] {&quot;&quot; ,&quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot; };    String[] thr = new String[] {&quot;&quot; ,&quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot; };    String[] fou = new String[] {&quot;&quot; ,&quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;};    return fou[num/1000]+ thr[num%1000/100] +two[num%100/10]+ one[num%10];  }  public static void main(String[] args){    IntToRoman toRoman = new IntToRoman();    String s = toRoman.intToRoman(1994);    System.out.println(s);  }}</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法14(字符串)-字符串数组的最长公共前缀</title>
      <link href="/2020/07/04/arithmtic/14-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/07/04/arithmtic/14-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>题目<br>编写一个函数来查找字符串数组中的最长公共前缀。<br> *</p><ul><li>如果不存在公共前缀，返回空字符串 “”。</li><li></li><li>示例 1:</li><li>输入: [“flower”,”flow”,”flight”]</li><li>输出: “fl”</li><li>示例 2:</li><li>输入: [“dog”,”racecar”,”car”]</li><li>输出: “”</li><li>解释: 输入不存在公共前缀。</li><li>说明:</li><li>所有输入只包含小写字母 a-z 。</li><li></li><li>来源：力扣（LeetCode）</li><li>链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix</a></li><li>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ul><p>解析：采用先保存你一个，然后后面的通过控制指针的方式进行按个遍历，采用暴力解法<br><img src="https://upload-images.jianshu.io/upload_images/22769532-4c9dc65d383b7676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>依次进行更新最小前缀的方式进行求解，如图</p><pre><code class="Java">public class longestCommonPrefix {  /**   * @param   * @return   */  public String longestCommonPrefix(String [] strs) {    //1.拿到每一个数组中的字符串，保存下来    //2.得到字符串中最小的一个长度，遍历此长度下的其余字符串的一个前n项的值是否相等，相等就返回相等的具体的字符，否则返回 &quot;&quot;    if(strs.length == 0 || strs == null){return &quot;&quot;;}    String prefix = strs[0];    int minLen = prefix.length();    //找到最小的一个长度，这个，最长前 缀取决于短边    for(int i=1; i&lt;strs.length; i++){      //遍历求最小的长度      if(strs[i].length() &lt; minLen) minLen = strs[i].length();    }    //进行于后面的字符串进行比较，比较得到最长的一个串进行输出    StringBuilder res = new StringBuilder();    for(int j=0; j&lt; minLen; j++){      char ch = strs[0].charAt(j);      for(int k=1; k&lt;strs.length ;k++){        if(ch != strs[k].charAt(j)){          return res.toString();        }      }      res.append(ch);    }    return res.toString();  }  public static void main(String[] args) {    System.out.println(new longestCommonPrefix().longestCommonPrefix(new String[]{&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;}));  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最长公共前缀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法13(字符串)-罗马数字转阿拉伯数字</title>
      <link href="/2020/07/04/arithmtic/13-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/07/04/arithmtic/13-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>题目：</p><pre><code>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 * * 字符          数值 * I             1 * V             5 * X             10 * L             50 * C             100 * D             500 * M             1000 * 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。 * * 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： * * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。  * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 * 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 *</code></pre><p>这个题就在于如果下一个元素所对应的值比当前值大，就是循环做加法，否则即使循环做减法例如：VII,做加法，IV就是做减法：具体代码如下</p><pre><code class="java">public class RomanToInt {  public int romanToInt(String s) {    int sum = 0;    //取到第一个的值    int preNum = getValue(s.charAt(0));    for(int i= 1;i&lt;s.length();i++){      int num = getValue(s.charAt(i));      if(preNum &lt; num){        sum -= preNum;      }else {        sum += preNum;      }      preNum = num;    }    sum += preNum;    return sum;  }  public int getValue(char ch){    switch (ch) {      case &#39;I&#39;:        return 1;      case &#39;V&#39;:        return 5;      case &#39;X&#39;:        return 10;      case &#39;L&#39;:        return 50;      case &#39;C&#39;:        return 100;      case &#39;D&#39;:        return 500;      case &#39;M&#39;:        return 1000;      default:return 0;    }  }  public static void main(String[] args) {    System.out.println(new RomanToInt().romanToInt(&quot;IV&quot;));  }}</code></pre><p>如果有不完善的地方请指出</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 循环 </tag>
            
            <tag> 函数调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法12(链表)-两两交换链表</title>
      <link href="/2020/07/04/arithmtic/12-%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/04/arithmtic/12-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>题目描述<br>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>其实我对于这道题的理解也不是特别的深刻，这道题采用递归是最简单的，下面是大佬对于递归的理解<br><a href="https://lyl0724.github.io/2020/01/25/1/" target="_blank" rel="noopener">https://lyl0724.github.io/2020/01/25/1/</a></p><p>再来说说我是怎么理解这道题的，首先既然要交换，肯定是两个一组才有机会进行交换，在进行交换的时候，本节点总是前一个当作后一个节点的next节点，后一节点作为本节点的头节点。递归调用只需要知道这几个条件：1.什么时候递归调用结束，2.本次递归调用给下层需要返回什么，递归调用结束时间。<br>下面的就是我的代码</p><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */  public ListNode swapPairs(ListNode head) {      if(head == null || head.next == null){return head;}      ListNode next = head.next;      head.next = swapPairs(next.next);      next.next = head;      return next;  }</code></pre><p>主要是一个算法，没有写具体的类</p><p>示例:</p><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法11(链表)-两个链表相加</title>
      <link href="/2020/07/04/arithmtic/11-%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/04/arithmtic/11-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>题目：<br>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><p>解析：<br>先当搬运工吧，这个是leetcode 的官方详解<br>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1l1 和 l2l2 的表头开始相加。由于每位数字都应当处于 0 \ldots 90…9 的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5 + 7 = 125+7=12。在这种情况下，我们会将当前位的数值设置为 22，并将进位 carry = 1carry=1 带入下一次迭代。进位 carrycarry 必定是 00 或 11，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 199+9+1=19。</p><p>伪代码如下：</p><p>将当前结点初始化为返回列表的哑结点。<br>将进位 carrycarry 初始化为 00。<br>将 pp 和 qq 分别初始化为列表 l1l1 和 l2l2 的头部。<br>遍历列表 l1l1 和 l2l2 直至到达它们的尾端。<br>将 xx 设为结点 pp 的值。如果 pp 已经到达 l1l1 的末尾，则将其值设置为 00。<br>将 yy 设为结点 qq 的值。如果 qq 已经到达 l2l2 的末尾，则将其值设置为 00。<br>设定 sum = x + y + carrysum=x+y+carry。<br>更新进位的值，carry = sum / 10carry=sum/10。<br>创建一个数值为 (sum \bmod 10)(summod10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。<br>同时，将 pp 和 qq 前进到下一个结点。<br>检查 carry = 1carry=1 是否成立，如果成立，则向返回列表追加一个含有数字 11 的新结点。<br>返回哑结点的下一个结点。<br>请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。</p><p>请特别注意以下情况：</p><p>测试用例    说明<br>l1=[0,1]l1=[0,1]，l2=[0,1,2]l2=[0,1,2]    当一个列表比另一个列表长时<br>l1=[]l1=[]，l2=[0,1]l2=[0,1]    当一个列表为空时，即出现空列表<br>l1=[9,9]l1=[9,9]，l2=[1]l2=[1]    求和运算最后可能出现额外的进位，这一点很容易被遗忘</p><hr><p><strong><em>java代码如下</em></strong></p><pre><code class="java">package com.cxy.linkedtable;/** * 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 * * 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 * * 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 * * 示例： * 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) * 输出：7 -&gt; 0 -&gt; 8 * 来源：力扣（LeetCode） *  public class ListNode { *  *     int val; *  *     ListNode next; *  *     ListNode(int x) { val = x; } *  * } * 链接：https://leetcode-cn.com/problems/add-two-numbers * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class AddTwoNumbers {  //相加算法  public ListNode addTwoNumbers(ListNode l1, ListNode l2) {    //极端情况，两个链表的头结点都为空，返回null    if(l1 == null &amp;&amp; l2 == null){return null;}    //进位    int addOne = 0;    //设置哑结点    ListNode dummy = new ListNode(0);    //head指向dummy，方便移动自己的新的链表    ListNode head = dummy;    while( l1 != null || l2 != null || addOne != 0){      //处理上下数字数量不一致的问题，如果      int val1 = l1==null ? 0: l1.val;      int val2 = l2==null ? 0: l2.val;      int sum = val1 + val2 + addOne;      head.next = new ListNode(sum%10);      head = head.next;      //判 null      //进位      addOne = sum / 10;      if(l1 != null) l1 = l1.next;      if(l2 != null) l2 = l2.next;      System.out.println(&quot;---&quot;);    }    return dummy.next;  }  //打印方法  public String print(ListNode test){    StringBuilder sb = new StringBuilder();    while (test.next != null){      sb.append(test.val +&quot;--&gt;&quot;);      test = test.next;    }    return sb.toString();  }  //内部类  public static class ListNode{    int val;    ListNode next;    public ListNode(int val){      this.val = val;    }  }  //测试用例l1:(2 -&gt; 4 -&gt; 3) + l2:(5 -&gt; 6 -&gt; 4)  public static void main(String[] args){    ListNode l1 = new ListNode(2);    l1.next = new ListNode(4);    l1.next.next = new ListNode(3);    ListNode l2 = new ListNode(5);    l1.next = new ListNode(6);    l1.next.next = new ListNode(4);    ListNode node = new AddTwoNumbers().addTwoNumbers(l1, l2);    System.out.println(node);    String s = new AddTwoNumbers().print(node);    System.out.println(s);  }}</code></pre><p>#注释都有详尽的说明，现在已经是凌晨了，我要睡觉了</p><p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法10(链表)-删除链表中的重复结点</title>
      <link href="/2020/07/04/arithmtic/10-%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/04/arithmtic/10-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>题目:<br>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:<br>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p><p>解析:本题是一个链表操作题，主要考察我们对于链表的整体熟悉程度，还是相对比较简单的，指针指向第一个结点，判断（如果当前元素的下一个结点的val值刚好等于当前结点的val值，只需要将当前指针指向下下个结点）。<br> 算法：循环的条件是当当前结点不为空并且当前结点的下一结点也不为空，如果存在下一结点的值等于当前结点值，就让当前指针指向当前指针的下一个结点，画一张图有助于理解。<br>图解如下<br><img src="https://upload-images.jianshu.io/upload_images/22769532-225d3875b3817ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>具体实现代码如下</p><pre><code class="Java">只是实现了算法的过程，没有写具体的类  public ListNode deleteDuplicates(ListNode head){    if(head == null)return head;    ListNode curr = head;    while (curr != null &amp;&amp; curr.next != null){      if(curr.next.val == curr.val){        curr.next = curr.next.next;      }else{        curr = curr.next;      }    }    return head;  }</code></pre><p>这里要将头结点保存下来，因为不保存下来的话，直接返回curr的话是返回的head.next结点链表，不是完整的链表。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法09(链表)-合并两个链表</title>
      <link href="/2020/07/04/arithmtic/09-%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/04/arithmtic/09-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>题目：<br>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4  —-&gt;l1<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4—-&gt;l2</p><p>解法1：暴力解法：因为l1和l2两个链表是升序排列顺序已经固定了的，一个指针指向l1的head,一个指针指向l2的头指针，如果l1.val&lt;l2.val，定义一个哑结点，将哑结点的next指向l1,并且移动哑结点指针，同时移动l1的指针指向，如果条件不成立，将哑结点的下一个结点指向l2 ,并且移动哑结点指向，同时移动l2的指向下一个。<br>代码设计如下：<br>ListNode类</p><pre><code class="java">package com.cxy.linkedtable;/** * 结点类 */public class ListNode {  int val;  //指向结点指针  ListNode next;  //  public ListNode(int val){    this.val = val;  }  public ListNode(int currData,ListNode next){    this.val = currData;    this.next = next;  }  public ListNode(){}  @Override  public String toString() {    ListNode head = this;    StringBuilder s = new StringBuilder();    while (head != null){      s.append(head.val+ &quot; &quot;);      head = head.next;    }    return s.toString();  }}</code></pre><p>逻辑实现类</p><pre><code class="java">package com.cxy.linkedtable;import javax.swing.*;public class MergTwoLTable {  public ListNode mergeTwoLists(ListNode l1,ListNode l2){    //创建一个哑结点()    ListNode dummp = new ListNode(-1);    ListNode curr = dummp;    if(l1 == null){return l2;}    if(l2 == null){return l1;}    while(l1 != null &amp;&amp; l2 != null){      if(l1.val &lt; l2.val){        curr.next = new ListNode(l1.val);        //移动l1,指向下一个结点        l1 = l1.next;      }else {        curr.next = new ListNode(l2.val);        l2 = l2.next;      }      //移动当前指针到下一个结点      curr = curr.next;    }    if(l1 == null){curr.next = l2;}    if(l2 == null){curr.next = l1;}    return dummp.next;  }  public static void main(String[] args) {    MergTwoLTable lTable = new MergTwoLTable();    ListNode l1 = new ListNode(1);    l1.next = new ListNode(2);    l1.next.next = new ListNode(4);    ListNode l2 = new ListNode(1);    l2.next = new ListNode(3);    l2.next.next = new ListNode(4);    ListNode node = lTable.mergeTwoLists(l1, l2);    System.out.println(node.toString());  }}</code></pre><p>本题采用暴力解法，效率不是很高，听官方讲可以采用递归，具体代码可以参考下面代码<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法08-盛最多水的容器</title>
      <link href="/2020/07/04/arithmtic/08/"/>
      <url>/2020/07/04/arithmtic/08/</url>
      
        <content type="html"><![CDATA[<p> 题目：给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>图如下：摘抄自leetcode<br><img src="https://upload-images.jianshu.io/upload_images/22769532-2320fc47f37e7251.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>输入：[1,8,6,2,5,4,8,3,7]，输出：49</p><p><strong><em>解法1</em></strong>：.既然给了我们一个数组，而且是求最大的盛水容量，这就避不开遍历循环，利用穷举法进行逐个循环。我们采用i，j下标进行循环遍历，求出最小高度和他们之间的宽度，长*宽就可以求出及具体的体积。这种方法也称为暴力解法。下面给出具体的代码。</p><pre><code class="java">package com.cxy.array;public class MaxArea {  public static int maxArea() {    int[] height = new int[]{1,8,6,2,5,4,8,3,7};    int res = 0;    for(int i=0; i&lt;height.length; i++){      int first = height[i];      for(int j=i+1; j&lt;height.length; j++){        //求出对应的距离        int width = j-i;        //下一个元素的高度        int next = height[j];        //求出最小高度        int minHeight = Math.min(first,next);         //每次循环将最大的值覆盖掉前面的值        res = Math.max(minHeight*width,res);      }    }     //返回值    return res;  }  //测试代码  public static void main(String[] args) {    int i = MaxArea.maxArea();    System.out.println(i);  }}</code></pre><p>分析时间复杂度:O(n2) 空间复杂度O(n)，如果数据量更多的话，我们消耗的资源将会更多。<br><strong><em>解法2</em></strong>：采用双指针进行动态的求解，其实是穷举法的演变，只是一个指针i,一个指针j，分别指向数组开始和结尾。在这个问题中，影响盛水多少一个是高度，一个是宽度，求最大值，那就宽度 和 两边指针对应的最小值要最大。如果左边指针固定，right[j]&gt;left[i]，如果我们移动右指针的话，下一次的体积一定会比当前小（因为我们已经假设right[j]&gt;left[i]），因为在左指针不动的情况下，右边移动，导致宽度变小，下一次一定比当前小。所以思路就出来了<br>思路：<br>  if(right[j]&gt;left[i]){移动左指针(i++)}else{移动右指针(j–)}<br>代码如下</p><pre><code class="java">package com.cxy.array;/** * 双指针法实现装最多水的体积 * 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 *  (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 * 说明：你不能倾斜容器，且 n 的值至少为 2。 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/container-with-most-water * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class MaxArea2 {  public static int maxArea() {    int[] height = new int[]{1,8,6,2,5,4,8,3,7};    //指向最右边的指针   和     结果    int j = height.length-1,res = 0;    for(int i=0;i&lt;height.length;){      if(i == j){        break;      }      //求出两边睡得长度更小，谁小谁就移动指针      int minH = Math.min(height[i],height[j]);      //将结果与上一次循环出来的结果进行比较，选出最大的一个      res = Math.max(res,minH*(j-i));      System.out.println(&quot;计算结果为：&quot;+res+&quot;  当给的j值：&quot;+j+&quot;当前的最小高度为：&quot;+minH+&quot; 中间的长度为&quot;+(j-i));      if(height[i]&lt;height[j]){        i++;      }else {        j--;      }    }    return res;  }  public static void main(String[] args) {    int i = MaxArea2.maxArea();    System.out.println(i);  }}</code></pre><p>打印的结果(可以结合代码和分析进行查看)</p><pre><code>&quot;C:\Program Files\Java\jdk1.8.0_162\bin\java.exe&quot; &quot;-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=54251:C:\Program Files\JetBrains\IntelliJ IDEA 2019.1.4\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;C:\Program Files\Java\jdk1.8.0_162\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\rt.jar;D:\IdeaWorkSpace\Algorithms\JinDianSuanFa\out\production\JinDianSuanFa;D:\mvnrep\junit\junit\4.12\junit-4.12.jar;D:\mvnrep\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar;D:\mvnrep\org\jetbrains\annotations\17.0.0\annotations-17.0.0.jar&quot; com.cxy.array.MaxArea2计算结果为：8  当给的j值：8当前的最小高度为：1 中间的长度为8计算结果为：49  当给的j值：8当前的最小高度为：7 中间的长度为7计算结果为：49  当给的j值：7当前的最小高度为：3 中间的长度为6计算结果为：49  当给的j值：6当前的最小高度为：8 中间的长度为5计算结果为：49  当给的j值：5当前的最小高度为：4 中间的长度为4计算结果为：49  当给的j值：4当前的最小高度为：5 中间的长度为3计算结果为：49  当给的j值：3当前的最小高度为：2 中间的长度为2计算结果为：49  当给的j值：2当前的最小高度为：6 中间的长度为149Process finished with exit code 0</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 暴力求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法07-删除数组中的指定值</title>
      <link href="/2020/07/04/arithmtic/07/"/>
      <url>/2020/07/04/arithmtic/07/</url>
      
        <content type="html"><![CDATA[<p>题目：<br>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong><em>思路：双指针，一个慢指针(i)，一个快指针(j)，如果nums[j]=val,就将快指针右移，即j++,慢指针不动，如果nums[j]!=val,将nums[i]=nums[j],同时进行i++和j++</em></strong></p><hr><p>代码：</p><pre><code class="java">public int removeElement(int[] nums,int val){    if(nums.length==0||nums==null){return 0;}    //慢指针    int i = 0;    for(int j=0;j&lt;nums.length;j++){      if(nums[j] != val){        nums[i] = nums[j];        //覆盖值之后i++指向下一个        i++;      }    }    for(int k:nums){      System.out.println(k);    }    return i;  }</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法06-删除数组中的重复项</title>
      <link href="/2020/07/04/arithmtic/06/"/>
      <url>/2020/07/04/arithmtic/06/</url>
      
        <content type="html"><![CDATA[<p>题目描述：<br>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><em>原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</em></strong></p><p>给定数组 nums = [1,1,2], </p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>你不需要考虑数组中超出新长度后面的元素。</p><hr><p>这道题我们可以不能构造数组来接收自己找到的数组，必须在原数组上进行修改，用后面的值来覆盖前面的值，并且数组除了重复的元素是一个递增的数组，这样我们就可以采用双指针来解答<br>思路：有一个左指针i，有一个右指针j，左指针从下标0开始，右指针比左指针大，大多少我们是不知道的，但刚开始的初值为i=0和j=1。<strong><em>当遇到nums[i] != nums[j]</em></strong>，将nums[i+1] = nums[j] 同时 i+1,j+1,移动到下一个位置。如果nums[j] == nums[j]，右指针+1,一个循环到数组的末尾（我也是借鉴的leetcode上大神写的，但你别说，他们代码写得是真的牛鼻）。</p><pre><code class="java">public int removeDuplicates(int[] nums) {    if(nums.length == 0){      return 0;    }    //右指针    int j = 1;    //左指针    int i = 0;    while (j &lt; nums.length){      //如果不相等，就将j那个位置的元素覆盖掉i+1上的元素      if(nums[j] != nums[i]){        nums[i+1] = nums[j];        //指针右指针右移        i++;      }      //左指针右移      j++;    }    return i+1;  }</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法05-接雨水</title>
      <link href="/2020/07/04/arithmtic/05/"/>
      <url>/2020/07/04/arithmtic/05/</url>
      
        <content type="html"><![CDATA[<p>题目描述：<br>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。如下图<br><img src="https://upload-images.jianshu.io/upload_images/22769532-224e5aa9c8c87521.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><pre><code>输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6</code></pre><p>***拿到此题，我当时脑子里也没有什么思路，但经过观察，能装水的地方都是凹陷的地方，只要我们找到这个凹陷的位置，以及他们两边的高度，就很容易求出能装多少水<br>思路：<br>  1.我们从左向右进行遍历的同时，将对应的数组下标索引存入一个栈中，并且栈中的出栈顺序是从大到小的一个递减的由规律的数字，利用这个特点，我们就可以维护一个最小栈。<br>  2.只有当当前索引处的高度比凹陷处高才有可能储存到水，并且储水的高度是由左右两边的高度最小值以及中间凹陷处决定。<br>  3.为什么我这里要实现内循环，主要是为了找到左边的边界，以便求出水的宽度<br>所以代码实现如下</p><pre><code class="java">package com.cxy.stack;import java.util.Stack;/** * 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 * 输入: [0,1,0,2,1,0,1,3,2,1,2,1] * 输出: 6 */public class Trap {  public int trap(int[] height) {    //创建栈用于保存给定的数组的下标值    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();    //存储返回结果和返回值    int i = 0,res=0;    //遍历整个数组    while(i&lt;height.length){      //内层循环目的是找到多个值之间到底有多长      //如果当前元素的高度大于前面一个，就要进行计算存储的水有多少      //判断的条件是栈不为空，并且当前元素的高度要大于前一个（查找左边界）      while(!stack.isEmpty() &amp;&amp; height[i]&gt;height[stack.peek()]){        //取出当前元素的高度        int currentHeight = height[i];        //中间凹陷的索引        int preIndex = stack.pop();        if(stack.isEmpty())break;        //找到中间凹陷处的高度        int centerHeight = height[preIndex];        //中间凹陷处的前一个元素的高度        int preHeight = height[stack.peek()];        //真正能够装水的高度=左右两边高度的最小值 - 中间凹陷的高度        int minHeight = Math.min(currentHeight,preHeight) - centerHeight;        //----------------------上面获取凹陷的高度--------------------------        //----------------------下面获取凹陷的宽度--------------------------        int width = i-stack.peek()-1;        res += width*minHeight;        //取出当前元素的前一个的前      }      //最后要将索引值+1进入下一个循环遍历      stack.push(i++);    }    return res;  }}</code></pre><p>其实还有其他解决方案，例如双指针，一个从左往右寻找最高的位置，一个从右往左找最高；暴力循环求解，动态规划（这个我不太会）</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 暴力求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法04-最小栈</title>
      <link href="/2020/07/04/arithmtic/04/"/>
      <url>/2020/07/04/arithmtic/04/</url>
      
        <content type="html"><![CDATA[<p>题目：设计一个支持 push ，pop ，top 操作，<strong>并能在常数时间内检索到最小元素的栈。(这个是这道题的考察重点)</strong></p><p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p><p>示例:</p><p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p><p>输出：<br>[null,null,null,null,-3,null,0,-2]</p><p>解释：<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p><hr><p>1.如果我们不考虑<strong><em>在常数时间内检索到最小元素的栈</em></strong>的情况的话，我们可以使用集合来完成这道题，因为集合是<strong><em>有序可重复的(跟数组是类似的，只是封装了比数组更强大的一些功能)</em></strong>，只是我们在寻找最小值的时候是遍历的整个数组，时间复杂度就变大了，具体的实现如下:</p><pre><code>class MinStack {    private List&lt;Integer&gt; list;    /** initialize your data structure here. */    public MinStack() {      //对象构造的时候才进行初始化      list = new ArrayList&lt;Integer&gt;();    }    public void push(int x) {      //将x入到list的末尾，一会儿直接获取末尾数字就能得到栈顶元素      list.add(x);    }    public void pop() {      //出栈，删除栈顶元素      list.remove(list.size()-1);    }    public int top() {      //查看栈顶元素      return list.get(list.size()-1);    }      //主要是这里不满足我们的需求    public int getMin() {      //第一个作为最小的      int min = list.get(0);      for(int i : list){        //如果有比第一个还小的，min 的值就更改为当前循环出来的值        if(i&lt;min){          min = i;        }      }      return min;    }}</code></pre><p>2.显然我们第一种方法是不满足我们题目要求的，我们可以采用辅助栈的方式来进行存储，<strong><em>注意：当进行出栈的时候，如果数字栈出栈的数字跟最小栈的栈顶元素相同，此最小栈也要出栈</em></strong></p><pre><code class="java">package com.cxy.stack;import java.util.ArrayDeque;import java.util.Deque;/** * 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 * * push(x) —— 将元素 x 推入栈中。 * pop() —— 删除栈顶的元素。 * top() —— 获取栈顶元素。 * getMin() —— 检索栈中的最小元素。 * * MinStack minStack = new MinStack(); * minStack.push(-2); * minStack.push(0); * minStack.push(-3); * minStack.getMin();   --&gt; 返回 -3. * minStack.pop(); * minStack.top();      --&gt; 返回 0. * minStack.getMin();   --&gt; 返回 -2. * 思想：每个数字入最小栈的时候先跟栈顶元素进行比较，如果比栈顶元素都小，入数字栈的同时要入最小栈 */public class MinStack {  /** initialize your data structure here. */  //数字栈  private Deque&lt;Integer&gt; numStack;  //最小栈  private Deque&lt;Integer&gt; minStack;  public MinStack() {    //在调用构造函数的时候才进行对象的初始化,开辟内存空间    numStack = new ArrayDeque&lt;&gt;();    minStack = new ArrayDeque&lt;&gt;();  }  public void push(int x) {    //每个数字入最小栈的时候先跟栈顶元素进行比较，如果比栈顶元素都小，入数字栈的同时要入最小栈    numStack.push(x);    if(minStack.size() ==0 || minStack.peek()&gt;=x){      minStack.push(x);    }  }  public void pop() {    //查看栈顶元素    //弹出栈顶元素,numStack出栈的元素minStack栈顶元素一致时，minStack栈顶元素也要出栈    int numPop = numStack.pop();    if(numPop == minStack.peek()){      minStack.pop();    }  }  public int top() {   return numStack.peek();  }  public int getMin() {    return minStack.peek();  }}</code></pre><p><strong>我们这里最好使用Deque这种数据结构，而不用原生的Stack，因为当你一开始就输pop()出栈的话，栈为空，抛异常就导致程序终止了，当然我们也可以捕获这个异常做处理（我懒所以直接用Deque，哈哈哈）</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 最小栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法03-有效的括号</title>
      <link href="/2020/07/04/arithmtic/03/"/>
      <url>/2020/07/04/arithmtic/03/</url>
      
        <content type="html"><![CDATA[<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>例如下面的输入：<br>{[]}—-&gt;返回true<br>()]—–&gt;返回false<br>{[(]}—-&gt;返回false</p><p>根据题目中所描述的，就拿第一个”{[]}”来说，字符串是否有效取决于刚才入栈的字符是否跟下一个入栈字符构成一对符号，我们只需要先将是{，[，(其中任意一种入栈，如果下一次入栈是”] } )”中的一种，判断栈顶元素的字符是否跟即将入栈的这个字符构成配对关系，这就是核心思想。关于如何匹配字符，我们可以采用map来存储键值对<br>，思路可以见下图<br><img src="https://upload-images.jianshu.io/upload_images/22769532-955bf0c7f3422449.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code class="java">class Solution {    public boolean isValid( String s) {    HashMap&lt;Character,Character&gt; map = new HashMap&lt;&gt;();    //将对应的符号放入map中，前面作为键，后面作为值    //注意这里键值对顺序为什么要这样    map.put(&#39;)&#39;,&#39;(&#39;);    map.put(&#39;}&#39;,&#39;{&#39;);    map.put(&#39;]&#39;,&#39;[&#39;);    Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();//    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();    if(s.length()==0 || s==null){return true;}    for(int i=0;i&lt;s.length();i++){      if(s.charAt(i) == &#39;[&#39; || s.charAt(i) == &#39;{&#39; || s.charAt(i) == &#39;(&#39;){        stack.push(s.charAt(i));      }else if(map.get(s.charAt(i)) == stack.peek()){        //如果下次循环的值作为键，得到的值跟栈顶元素相同，就让栈顶元素出栈        System.out.println(&quot;栈顶元素为：&quot;+stack.peek());        stack.pop();      }else{        return false;      }    }    return stack.isEmpty();  }}</code></pre><p>……………… 这道题目的注意点： ……………………<br>数据结构最好是使用Deque这种类型，类似于栈，但是这个对与stack扩充了一些东西，直接使用原生数据结构stack，直接输入]就会导致栈空，抛出异常，程序就没办法执行下去了，但是程序本身是没有什么问题的，你调用stack.peek()查看栈顶元素就抛出了EmptyStackException,但是Deque封装了一些方法，检查空栈的栈顶元素的时候不会抛异常，会给你返回null。第二个注意点就是map存的键值：我们是通过}  ] ）当做键，[ { (作为值与栈顶元素进行比较。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 最小栈 </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法02-求1-n的和高级求法</title>
      <link href="/2020/07/04/arithmtic/02/"/>
      <url>/2020/07/04/arithmtic/02/</url>
      
        <content type="html"><![CDATA[<p>题目要求：<br><strong>不能使用for while 等循环语句; if() else;  switch case;等系列判断语句</strong><br>示例 1</p><pre><code class="text">输入3输出6</code></pre><p>思路1：<br>    利用高斯定理：等差数列求和（sum = (首项+末项)*项数/2）</p><pre><code class="java">public class Test {  public int sumNumber(int n){    return (int)(1+n)*n/2;  }  public static void main(String[] args) {    Test test = new Test();    System.out.println(&quot;input a number&quot;);    Scanner scanner = new Scanner(System.in);    test.sumNumber(scanner.nextInt());  }}</code></pre><p>思路2<br>利用递归和短路与的特点进行计算</p><pre><code class="java">public int sumNumber(int n){    //return (int)(1+n)*n/2;    int sum = n;    //后面的sum+=sumNumber()递归调用的只可能是正数，当n=0时候不满足条件了，逐层进行调用得到结果    boolean flag = n&gt;0 &amp;&amp; (sum+=sumNumber(n-1))&gt;0;    return sum;  }</code></pre><p>这就是主要的两种思路，有其他好方法的伙伴可以在评论区留言</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 1-n的和 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法01-表达式求值</title>
      <link href="/2020/07/04/arithmtic/01/"/>
      <url>/2020/07/04/arithmtic/01/</url>
      
        <content type="html"><![CDATA[<hr><p>题目给出：本题主要是算法第四版上的一道题目<br>计算(1+((2+3)<em>(4</em>5)))的值</p><p>解析：1.这道题，我们可以看到有操作数和操作符，我们可以利用两个栈来解决这个问题，一个操作数栈，一个操作符栈，分别为opertor,number。2.判断操作数出栈的条件是遇到 “)” 括号，遇到右括号就要进行操作符出栈（这里会遇到弹出的操作符不是我们想要的操作符，而是”(“ 这样我们就要将操作符栈再次出栈），对应的操作数栈相邻的两个操作数出栈，做算术表达式后进行再次入操作数栈。3.当操作数栈为空的时候，最后一次出操作数栈的就是我们计算得到的值。</p><p>直接上代码</p><pre><code class="java">package com.cxy.stack;import java.util.Scanner;import java.util.Stack;public class ArithmeticExpression {public static void main(String[] args){    System.out.println(&quot;请输入一串带（）+数字的算术表达式：例如(1+((2+3)*(4*5)))&quot;);    Scanner scanner =new Scanner(System.in);    String input = scanner.nextLine();    System.out.println(input);    //操作符栈    Stack opertor =new Stack&lt;&gt;();    //操作数栈    Stack number =new Stack&lt;&gt;();    //保存最终数据的    double res =0;    int index =0;    int len = input.length();    while(len&gt;0){      //index控制表达式的字符位置      len--;      //中间临时保存计算值      String tempOperator =null;      char ch = input.charAt(index);      index++;      if(ch ==&#39;+&#39;|| ch ==&#39;-&#39; || ch ==&#39;*&#39; || ch ==&#39;/&#39; || ch ==&#39;(&#39;){        //如果是操作符，        System.out.println(&quot;入操作符栈：&quot;+ch);        opertor.push(Character.toString(ch));      }else if(ch !=&#39;)&#39;){        System.out.println(&quot;入操作数栈：&quot;+ch);        number.push(Double.parseDouble(Character.toString(ch)));      }else if(ch ==&#39;)&#39;){        //遇到右括号，出操作符栈,并执行相应的number出栈        System.out.println(&quot;遇到右括号&quot;);        tempOperator = opertor.pop();        //再出一次操作符栈将（括号去掉        String leftKuo = opertor.pop();        System.out.println(&quot;遇到右括号出栈的字符：&quot;+tempOperator);        System.out.println(&quot;将左括号去电&quot;+leftKuo);        //出第一个number//        System.out.println(&quot;操作数右边的数：&quot;+firstNumber);        if(tempOperator.equals(&quot;+&quot;)){          double firstNumber = number.pop();          double lastNumber = number.pop();          //计算之后将新得到的数字继续入数字栈          System.out.println(&quot;加号左边出操作数：&quot;+lastNumber);          number.push(lastNumber+firstNumber);          System.out.println(&quot;两边相加的操作数入栈：&quot;+lastNumber+firstNumber);          System.out.println(&quot;相加后的栈长度：&quot;+number.size());        }else if(tempOperator.equals(&quot;-&quot;)){          //后出栈的减前面的          double firstNumber = number.pop();          number.push(number.pop()-firstNumber);        }else if(tempOperator.equals(&quot;*&quot;)){          double firstNumber = number.pop();          double lastNumber = number.pop();          System.out.println(&quot;乘号右边&quot;+firstNumber);          System.out.println(&quot;乘号左边&quot;+lastNumber);          number.push(lastNumber*firstNumber);          System.out.println(&quot;相乘的两边的操作数入栈：&quot;+firstNumber*lastNumber);          System.out.println(&quot;相乘后的栈长度：&quot;+number.size());        }else if(tempOperator.equals(&quot;/&quot;)){          double firstNumber = number.pop();          //如果分母为0，提示错误          if(firstNumber ==0){            System.out.println(&quot;分母为0，无法计算&quot;);break;          }else          number.push(number.pop()/firstNumber);        }}}    System.out.println(&quot;计算结果为：&quot;+number.pop());  }}</code></pre><p>最后输出结果</p><pre><code>&quot;C:\Program Files\Java\jdk1.8.0_162\bin\java.exe&quot; &quot;-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=50194:C:\Program Files\JetBrains\IntelliJ IDEA 2019.1.4\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;C:\Program Files\Java\jdk1.8.0_162\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_162\jre\lib\rt.jar;D:\IdeaWorkSpace\Algorithms\JinDianSuanFa\out\production\JinDianSuanFa;D:\mvnrep\junit\junit\4.12\junit-4.12.jar;D:\mvnrep\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar&quot; com.cxy.stack.Arithmetic请输入一串带（）+数字的算术表达式：例如(1+((2+3)*(4*5)))(1+((2+3)*(4*5)))(1+((2+3)*(4*5)))入操作符栈：(入操作数栈：1入操作符栈：+入操作符栈：(入操作符栈：(入操作数栈：2入操作符栈：+入操作数栈：3遇到右括号遇到右括号出栈的字符：+将左括号去电(加号左边出操作数：2.0两边相加的操作数入栈：2.03.0相加后的栈长度：2入操作符栈：*入操作符栈：(入操作数栈：4入操作符栈：*入操作数栈：5遇到右括号遇到右括号出栈的字符：*将左括号去电(乘号右边5.0乘号左边4.0相乘的两边的操作数入栈：20.0相乘后的栈长度：3遇到右括号遇到右括号出栈的字符：*将左括号去电(乘号右边20.0乘号左边5.0相乘的两边的操作数入栈：100.0相乘后的栈长度：2遇到右括号遇到右括号出栈的字符：+将左括号去电(加号左边出操作数：1.0两边相加的操作数入栈：1.0100.0相加后的栈长度：1计算结果为：101.0Process finished with exit code 0</code></pre><h2 id="其实还有很多地方需要考虑，比如用户输入的数据进行校验，小伙伴儿们可以进行参考和修改"><a href="#其实还有很多地方需要考虑，比如用户输入的数据进行校验，小伙伴儿们可以进行参考和修改" class="headerlink" title="其实还有很多地方需要考虑，比如用户输入的数据进行校验，小伙伴儿们可以进行参考和修改"></a>其实还有很多地方需要考虑，比如用户输入的数据进行校验，小伙伴儿们可以进行参考和修改</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 表达式求值 </tag>
            
            <tag> 操作符，操作数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
